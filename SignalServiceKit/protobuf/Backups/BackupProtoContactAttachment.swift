//
// Copyright 2024 Signal Messenger, LLC
// SPDX-License-Identifier: AGPL-3.0-only
//

// Code generated by Wire protocol buffer compiler, do not edit.
// Source: BackupProto.BackupProtoContactAttachment in Backup.proto
import Wire

public struct BackupProtoContactAttachment {

    @ProtoDefaulted
    public var name: BackupProtoContactAttachment.BackupProtoName?
    public var number: [BackupProtoContactAttachment.BackupProtoPhone] = []
    public var email: [BackupProtoContactAttachment.BackupProtoEmail] = []
    public var address: [BackupProtoContactAttachment.BackupProtoPostalAddress] = []
    @ProtoDefaulted
    public var avatar: BackupProtoContactAttachment.BackupProtoAvatar?
    @ProtoDefaulted
    public var organization: String?
    public var unknownFields: UnknownFields = .init()

    public init(configure: (inout Self) -> Swift.Void = { _ in }) {
        configure(&self)
    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoContactAttachment : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoContactAttachment : Hashable {
}
#endif

extension BackupProtoContactAttachment : Sendable {
}

extension BackupProtoContactAttachment : ProtoDefaultedValue {

    public static var defaultedValue: BackupProtoContactAttachment {
        BackupProtoContactAttachment()
    }
}

extension BackupProtoContactAttachment : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProtoContactAttachment"
    }

}

extension BackupProtoContactAttachment : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var name: BackupProtoContactAttachment.BackupProtoName? = nil
        var number: [BackupProtoContactAttachment.BackupProtoPhone] = []
        var email: [BackupProtoContactAttachment.BackupProtoEmail] = []
        var address: [BackupProtoContactAttachment.BackupProtoPostalAddress] = []
        var avatar: BackupProtoContactAttachment.BackupProtoAvatar? = nil
        var organization: String? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: name = try protoReader.decode(BackupProtoContactAttachment.BackupProtoName.self)
            case 3: try protoReader.decode(into: &number)
            case 4: try protoReader.decode(into: &email)
            case 5: try protoReader.decode(into: &address)
            case 6: avatar = try protoReader.decode(BackupProtoContactAttachment.BackupProtoAvatar.self)
            case 7: organization = try protoReader.decode(String.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._name.wrappedValue = name
        self.number = number
        self.email = email
        self.address = address
        self._avatar.wrappedValue = avatar
        self._organization.wrappedValue = organization
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.name)
        try protoWriter.encode(tag: 3, value: self.number)
        try protoWriter.encode(tag: 4, value: self.email)
        try protoWriter.encode(tag: 5, value: self.address)
        try protoWriter.encode(tag: 6, value: self.avatar)
        try protoWriter.encode(tag: 7, value: self.organization)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProtoContactAttachment : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._name.wrappedValue = try container.decodeIfPresent(BackupProtoContactAttachment.BackupProtoName.self, forKey: "name")
        self.number = try container.decodeProtoArray(BackupProtoContactAttachment.BackupProtoPhone.self, forKey: "number")
        self.email = try container.decodeProtoArray(BackupProtoContactAttachment.BackupProtoEmail.self, forKey: "email")
        self.address = try container.decodeProtoArray(BackupProtoContactAttachment.BackupProtoPostalAddress.self, forKey: "address")
        self._avatar.wrappedValue = try container.decodeIfPresent(BackupProtoContactAttachment.BackupProtoAvatar.self, forKey: "avatar")
        self._organization.wrappedValue = try container.decodeIfPresent(String.self, forKey: "organization")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        try container.encodeIfPresent(self.name, forKey: "name")
        if includeDefaults || !self.number.isEmpty {
            try container.encodeProtoArray(self.number, forKey: "number")
        }
        if includeDefaults || !self.email.isEmpty {
            try container.encodeProtoArray(self.email, forKey: "email")
        }
        if includeDefaults || !self.address.isEmpty {
            try container.encodeProtoArray(self.address, forKey: "address")
        }
        try container.encodeIfPresent(self.avatar, forKey: "avatar")
        try container.encodeIfPresent(self.organization, forKey: "organization")
    }

}
#endif

/**
 * Subtypes within BackupProtoContactAttachment
 */
extension BackupProtoContactAttachment {

    public struct BackupProtoName {

        @ProtoDefaulted
        public var givenName: String?
        @ProtoDefaulted
        public var familyName: String?
        @ProtoDefaulted
        public var prefix: String?
        @ProtoDefaulted
        public var suffix: String?
        @ProtoDefaulted
        public var middleName: String?
        @ProtoDefaulted
        public var displayName: String?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct BackupProtoPhone {

        @ProtoDefaulted
        public var value: String?
        @ProtoDefaulted
        public var type: BackupProtoContactAttachment.BackupProtoPhone.BackupProtoType?
        @ProtoDefaulted
        public var label: String?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct BackupProtoEmail {

        @ProtoDefaulted
        public var value: String?
        @ProtoDefaulted
        public var type: BackupProtoContactAttachment.BackupProtoEmail.BackupProtoType?
        @ProtoDefaulted
        public var label: String?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct BackupProtoPostalAddress {

        @ProtoDefaulted
        public var type: BackupProtoContactAttachment.BackupProtoPostalAddress.BackupProtoType?
        @ProtoDefaulted
        public var label: String?
        @ProtoDefaulted
        public var street: String?
        @ProtoDefaulted
        public var pobox: String?
        @ProtoDefaulted
        public var neighborhood: String?
        @ProtoDefaulted
        public var city: String?
        @ProtoDefaulted
        public var region: String?
        @ProtoDefaulted
        public var postcode: String?
        @ProtoDefaulted
        public var country: String?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct BackupProtoAvatar {

        @ProtoDefaulted
        public var avatar: BackupProtoFilePointer?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoContactAttachment.BackupProtoName : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoContactAttachment.BackupProtoName : Hashable {
}
#endif

extension BackupProtoContactAttachment.BackupProtoName : Sendable {
}

extension BackupProtoContactAttachment.BackupProtoName : ProtoDefaultedValue {

    public static var defaultedValue: BackupProtoContactAttachment.BackupProtoName {
        BackupProtoContactAttachment.BackupProtoName()
    }
}

extension BackupProtoContactAttachment.BackupProtoName : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProtoContactAttachment.BackupProtoName"
    }

}

extension BackupProtoContactAttachment.BackupProtoName : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var givenName: String? = nil
        var familyName: String? = nil
        var prefix: String? = nil
        var suffix: String? = nil
        var middleName: String? = nil
        var displayName: String? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: givenName = try protoReader.decode(String.self)
            case 2: familyName = try protoReader.decode(String.self)
            case 3: prefix = try protoReader.decode(String.self)
            case 4: suffix = try protoReader.decode(String.self)
            case 5: middleName = try protoReader.decode(String.self)
            case 6: displayName = try protoReader.decode(String.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._givenName.wrappedValue = givenName
        self._familyName.wrappedValue = familyName
        self._prefix.wrappedValue = prefix
        self._suffix.wrappedValue = suffix
        self._middleName.wrappedValue = middleName
        self._displayName.wrappedValue = displayName
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.givenName)
        try protoWriter.encode(tag: 2, value: self.familyName)
        try protoWriter.encode(tag: 3, value: self.prefix)
        try protoWriter.encode(tag: 4, value: self.suffix)
        try protoWriter.encode(tag: 5, value: self.middleName)
        try protoWriter.encode(tag: 6, value: self.displayName)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProtoContactAttachment.BackupProtoName : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._givenName.wrappedValue = try container.decodeIfPresent(String.self, forKey: "givenName")
        self._familyName.wrappedValue = try container.decodeIfPresent(String.self, forKey: "familyName")
        self._prefix.wrappedValue = try container.decodeIfPresent(String.self, forKey: "prefix")
        self._suffix.wrappedValue = try container.decodeIfPresent(String.self, forKey: "suffix")
        self._middleName.wrappedValue = try container.decodeIfPresent(String.self, forKey: "middleName")
        self._displayName.wrappedValue = try container.decodeIfPresent(String.self, forKey: "displayName")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(self.givenName, forKey: "givenName")
        try container.encodeIfPresent(self.familyName, forKey: "familyName")
        try container.encodeIfPresent(self.prefix, forKey: "prefix")
        try container.encodeIfPresent(self.suffix, forKey: "suffix")
        try container.encodeIfPresent(self.middleName, forKey: "middleName")
        try container.encodeIfPresent(self.displayName, forKey: "displayName")
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoContactAttachment.BackupProtoPhone : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoContactAttachment.BackupProtoPhone : Hashable {
}
#endif

extension BackupProtoContactAttachment.BackupProtoPhone : Sendable {
}

extension BackupProtoContactAttachment.BackupProtoPhone : ProtoDefaultedValue {

    public static var defaultedValue: BackupProtoContactAttachment.BackupProtoPhone {
        BackupProtoContactAttachment.BackupProtoPhone()
    }
}

extension BackupProtoContactAttachment.BackupProtoPhone : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProtoContactAttachment.BackupProtoPhone"
    }

}

extension BackupProtoContactAttachment.BackupProtoPhone : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var value: String? = nil
        var type: BackupProtoContactAttachment.BackupProtoPhone.BackupProtoType? = nil
        var label: String? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: value = try protoReader.decode(String.self)
            case 2: type = try protoReader.decode(BackupProtoContactAttachment.BackupProtoPhone.BackupProtoType.self)
            case 3: label = try protoReader.decode(String.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._value.wrappedValue = value
        self._type.wrappedValue = try BackupProtoContactAttachment.BackupProtoPhone.BackupProtoType.defaultIfMissing(type)
        self._label.wrappedValue = label
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.value)
        try protoWriter.encode(tag: 2, value: self.type)
        try protoWriter.encode(tag: 3, value: self.label)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProtoContactAttachment.BackupProtoPhone : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._value.wrappedValue = try container.decodeIfPresent(String.self, forKey: "value")
        self._type.wrappedValue = try container.decodeIfPresent(BackupProtoContactAttachment.BackupProtoPhone.BackupProtoType.self, forKey: "type")
        self._label.wrappedValue = try container.decodeIfPresent(String.self, forKey: "label")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(self.value, forKey: "value")
        try container.encodeIfPresent(self.type, forKey: "type")
        try container.encodeIfPresent(self.label, forKey: "label")
    }

}
#endif

/**
 * Subtypes within BackupProtoContactAttachment.BackupProtoPhone
 */
extension BackupProtoContactAttachment.BackupProtoPhone {

    public enum BackupProtoType : Int32, CaseIterable, ProtoEnum, ProtoDefaultedValue {

        case UNKNOWN = 0
        case HOME = 1
        case MOBILE = 2
        case WORK = 3
        case CUSTOM = 4

        public static var defaultedValue: BackupProtoContactAttachment.BackupProtoPhone.BackupProtoType {
            BackupProtoContactAttachment.BackupProtoPhone.BackupProtoType.UNKNOWN
        }
        public var description: String {
            switch self {
            case .UNKNOWN: return "UNKNOWN"
            case .HOME: return "HOME"
            case .MOBILE: return "MOBILE"
            case .WORK: return "WORK"
            case .CUSTOM: return "CUSTOM"
            }
        }

    }

}

extension BackupProtoContactAttachment.BackupProtoPhone.BackupProtoType : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoContactAttachment.BackupProtoEmail : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoContactAttachment.BackupProtoEmail : Hashable {
}
#endif

extension BackupProtoContactAttachment.BackupProtoEmail : Sendable {
}

extension BackupProtoContactAttachment.BackupProtoEmail : ProtoDefaultedValue {

    public static var defaultedValue: BackupProtoContactAttachment.BackupProtoEmail {
        BackupProtoContactAttachment.BackupProtoEmail()
    }
}

extension BackupProtoContactAttachment.BackupProtoEmail : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProtoContactAttachment.BackupProtoEmail"
    }

}

extension BackupProtoContactAttachment.BackupProtoEmail : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var value: String? = nil
        var type: BackupProtoContactAttachment.BackupProtoEmail.BackupProtoType? = nil
        var label: String? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: value = try protoReader.decode(String.self)
            case 2: type = try protoReader.decode(BackupProtoContactAttachment.BackupProtoEmail.BackupProtoType.self)
            case 3: label = try protoReader.decode(String.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._value.wrappedValue = value
        self._type.wrappedValue = try BackupProtoContactAttachment.BackupProtoEmail.BackupProtoType.defaultIfMissing(type)
        self._label.wrappedValue = label
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.value)
        try protoWriter.encode(tag: 2, value: self.type)
        try protoWriter.encode(tag: 3, value: self.label)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProtoContactAttachment.BackupProtoEmail : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._value.wrappedValue = try container.decodeIfPresent(String.self, forKey: "value")
        self._type.wrappedValue = try container.decodeIfPresent(BackupProtoContactAttachment.BackupProtoEmail.BackupProtoType.self, forKey: "type")
        self._label.wrappedValue = try container.decodeIfPresent(String.self, forKey: "label")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(self.value, forKey: "value")
        try container.encodeIfPresent(self.type, forKey: "type")
        try container.encodeIfPresent(self.label, forKey: "label")
    }

}
#endif

/**
 * Subtypes within BackupProtoContactAttachment.BackupProtoEmail
 */
extension BackupProtoContactAttachment.BackupProtoEmail {

    public enum BackupProtoType : Int32, CaseIterable, ProtoEnum, ProtoDefaultedValue {

        case UNKNOWN = 0
        case HOME = 1
        case MOBILE = 2
        case WORK = 3
        case CUSTOM = 4

        public static var defaultedValue: BackupProtoContactAttachment.BackupProtoEmail.BackupProtoType {
            BackupProtoContactAttachment.BackupProtoEmail.BackupProtoType.UNKNOWN
        }
        public var description: String {
            switch self {
            case .UNKNOWN: return "UNKNOWN"
            case .HOME: return "HOME"
            case .MOBILE: return "MOBILE"
            case .WORK: return "WORK"
            case .CUSTOM: return "CUSTOM"
            }
        }

    }

}

extension BackupProtoContactAttachment.BackupProtoEmail.BackupProtoType : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoContactAttachment.BackupProtoPostalAddress : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoContactAttachment.BackupProtoPostalAddress : Hashable {
}
#endif

extension BackupProtoContactAttachment.BackupProtoPostalAddress : Sendable {
}

extension BackupProtoContactAttachment.BackupProtoPostalAddress : ProtoDefaultedValue {

    public static var defaultedValue: BackupProtoContactAttachment.BackupProtoPostalAddress {
        BackupProtoContactAttachment.BackupProtoPostalAddress()
    }
}

extension BackupProtoContactAttachment.BackupProtoPostalAddress : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProtoContactAttachment.BackupProtoPostalAddress"
    }

}

extension BackupProtoContactAttachment.BackupProtoPostalAddress : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var type: BackupProtoContactAttachment.BackupProtoPostalAddress.BackupProtoType? = nil
        var label: String? = nil
        var street: String? = nil
        var pobox: String? = nil
        var neighborhood: String? = nil
        var city: String? = nil
        var region: String? = nil
        var postcode: String? = nil
        var country: String? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: type = try protoReader.decode(BackupProtoContactAttachment.BackupProtoPostalAddress.BackupProtoType.self)
            case 2: label = try protoReader.decode(String.self)
            case 3: street = try protoReader.decode(String.self)
            case 4: pobox = try protoReader.decode(String.self)
            case 5: neighborhood = try protoReader.decode(String.self)
            case 6: city = try protoReader.decode(String.self)
            case 7: region = try protoReader.decode(String.self)
            case 8: postcode = try protoReader.decode(String.self)
            case 9: country = try protoReader.decode(String.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._type.wrappedValue = try BackupProtoContactAttachment.BackupProtoPostalAddress.BackupProtoType.defaultIfMissing(type)
        self._label.wrappedValue = label
        self._street.wrappedValue = street
        self._pobox.wrappedValue = pobox
        self._neighborhood.wrappedValue = neighborhood
        self._city.wrappedValue = city
        self._region.wrappedValue = region
        self._postcode.wrappedValue = postcode
        self._country.wrappedValue = country
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.type)
        try protoWriter.encode(tag: 2, value: self.label)
        try protoWriter.encode(tag: 3, value: self.street)
        try protoWriter.encode(tag: 4, value: self.pobox)
        try protoWriter.encode(tag: 5, value: self.neighborhood)
        try protoWriter.encode(tag: 6, value: self.city)
        try protoWriter.encode(tag: 7, value: self.region)
        try protoWriter.encode(tag: 8, value: self.postcode)
        try protoWriter.encode(tag: 9, value: self.country)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProtoContactAttachment.BackupProtoPostalAddress : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._type.wrappedValue = try container.decodeIfPresent(BackupProtoContactAttachment.BackupProtoPostalAddress.BackupProtoType.self, forKey: "type")
        self._label.wrappedValue = try container.decodeIfPresent(String.self, forKey: "label")
        self._street.wrappedValue = try container.decodeIfPresent(String.self, forKey: "street")
        self._pobox.wrappedValue = try container.decodeIfPresent(String.self, forKey: "pobox")
        self._neighborhood.wrappedValue = try container.decodeIfPresent(String.self, forKey: "neighborhood")
        self._city.wrappedValue = try container.decodeIfPresent(String.self, forKey: "city")
        self._region.wrappedValue = try container.decodeIfPresent(String.self, forKey: "region")
        self._postcode.wrappedValue = try container.decodeIfPresent(String.self, forKey: "postcode")
        self._country.wrappedValue = try container.decodeIfPresent(String.self, forKey: "country")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(self.type, forKey: "type")
        try container.encodeIfPresent(self.label, forKey: "label")
        try container.encodeIfPresent(self.street, forKey: "street")
        try container.encodeIfPresent(self.pobox, forKey: "pobox")
        try container.encodeIfPresent(self.neighborhood, forKey: "neighborhood")
        try container.encodeIfPresent(self.city, forKey: "city")
        try container.encodeIfPresent(self.region, forKey: "region")
        try container.encodeIfPresent(self.postcode, forKey: "postcode")
        try container.encodeIfPresent(self.country, forKey: "country")
    }

}
#endif

/**
 * Subtypes within BackupProtoContactAttachment.BackupProtoPostalAddress
 */
extension BackupProtoContactAttachment.BackupProtoPostalAddress {

    public enum BackupProtoType : Int32, CaseIterable, ProtoEnum, ProtoDefaultedValue {

        case UNKNOWN = 0
        case HOME = 1
        case WORK = 2
        case CUSTOM = 3

        public static var defaultedValue: BackupProtoContactAttachment.BackupProtoPostalAddress.BackupProtoType {
            BackupProtoContactAttachment.BackupProtoPostalAddress.BackupProtoType.UNKNOWN
        }
        public var description: String {
            switch self {
            case .UNKNOWN: return "UNKNOWN"
            case .HOME: return "HOME"
            case .WORK: return "WORK"
            case .CUSTOM: return "CUSTOM"
            }
        }

    }

}

extension BackupProtoContactAttachment.BackupProtoPostalAddress.BackupProtoType : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoContactAttachment.BackupProtoAvatar : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoContactAttachment.BackupProtoAvatar : Hashable {
}
#endif

extension BackupProtoContactAttachment.BackupProtoAvatar : Sendable {
}

extension BackupProtoContactAttachment.BackupProtoAvatar : ProtoDefaultedValue {

    public static var defaultedValue: BackupProtoContactAttachment.BackupProtoAvatar {
        BackupProtoContactAttachment.BackupProtoAvatar()
    }
}

extension BackupProtoContactAttachment.BackupProtoAvatar : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProtoContactAttachment.BackupProtoAvatar"
    }

}

extension BackupProtoContactAttachment.BackupProtoAvatar : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var avatar: BackupProtoFilePointer? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: avatar = try protoReader.decode(BackupProtoFilePointer.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._avatar.wrappedValue = avatar
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.avatar)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProtoContactAttachment.BackupProtoAvatar : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._avatar.wrappedValue = try container.decodeIfPresent(BackupProtoFilePointer.self, forKey: "avatar")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(self.avatar, forKey: "avatar")
    }

}
#endif
