//
// Copyright 2024 Signal Messenger, LLC
// SPDX-License-Identifier: AGPL-3.0-only
//

// Code generated by Wire protocol buffer compiler, do not edit.
// Source: BackupProto.BackupProtoChatItem in Backup.proto
import Wire

public struct BackupProtoChatItem {

    /**
     * conversation id
     */
    public var chatId: UInt64
    /**
     * recipient id
     */
    public var authorId: UInt64
    public var dateSent: UInt64
    public var sealedSender: Bool
    /**
     * timestamp of when expiration timer started ticking down
     */
    @ProtoDefaulted
    public var expireStartDate: UInt64?
    /**
     * how long timer of message is (ms)
     */
    @ProtoDefaulted
    public var expiresInMs: UInt64?
    /**
     * ordered from oldest to newest
     */
    public var revisions: [BackupProtoChatItem] = []
    public var sms: Bool
    public var directionalDetails: DirectionalDetails?
    public var item: Item?
    public var unknownFields: UnknownFields = .init()

    public init(
        chatId: UInt64,
        authorId: UInt64,
        dateSent: UInt64,
        sealedSender: Bool,
        sms: Bool,
        configure: (inout Self) -> Swift.Void = { _ in }
    ) {
        self.chatId = chatId
        self.authorId = authorId
        self.dateSent = dateSent
        self.sealedSender = sealedSender
        self.sms = sms
        configure(&self)
    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoChatItem : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoChatItem : Hashable {
}
#endif

extension BackupProtoChatItem : Sendable {
}

extension BackupProtoChatItem : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProtoChatItem"
    }

}

extension BackupProtoChatItem : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var chatId: UInt64 = 0
        var authorId: UInt64 = 0
        var dateSent: UInt64 = 0
        var sealedSender: Bool = false
        var expireStartDate: UInt64? = nil
        var expiresInMs: UInt64? = nil
        var revisions: [BackupProtoChatItem] = []
        var sms: Bool = false
        var directionalDetails: DirectionalDetails? = nil
        var item: Item? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: chatId = try protoReader.decode(UInt64.self)
            case 2: authorId = try protoReader.decode(UInt64.self)
            case 3: dateSent = try protoReader.decode(UInt64.self)
            case 4: sealedSender = try protoReader.decode(Bool.self)
            case 5: expireStartDate = try protoReader.decode(UInt64.self)
            case 6: expiresInMs = try protoReader.decode(UInt64.self)
            case 7: try protoReader.decode(into: &revisions)
            case 8: sms = try protoReader.decode(Bool.self)
            case 9: directionalDetails = .incoming(try protoReader.decode(BackupProtoChatItem.BackupProtoIncomingMessageDetails.self))
            case 10: directionalDetails = .outgoing(try protoReader.decode(BackupProtoChatItem.BackupProtoOutgoingMessageDetails.self))
            case 11: directionalDetails = .directionless(try protoReader.decode(BackupProtoChatItem.BackupProtoDirectionlessMessageDetails.self))
            case 13: item = .standardMessage(try protoReader.decode(BackupProtoStandardMessage.self))
            case 14: item = .contactMessage(try protoReader.decode(BackupProtoContactMessage.self))
            case 15: item = .voiceMessage(try protoReader.decode(BackupProtoVoiceMessage.self))
            case 16: item = .stickerMessage(try protoReader.decode(BackupProtoStickerMessage.self))
            case 17: item = .remoteDeletedMessage(try protoReader.decode(BackupProtoRemoteDeletedMessage.self))
            case 18: item = .updateMessage(try protoReader.decode(BackupProtoChatUpdateMessage.self))
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.chatId = chatId
        self.authorId = authorId
        self.dateSent = dateSent
        self.sealedSender = sealedSender
        self._expireStartDate.wrappedValue = expireStartDate
        self._expiresInMs.wrappedValue = expiresInMs
        self.revisions = revisions
        self.sms = sms
        self.directionalDetails = directionalDetails
        self.item = item
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.chatId)
        try protoWriter.encode(tag: 2, value: self.authorId)
        try protoWriter.encode(tag: 3, value: self.dateSent)
        try protoWriter.encode(tag: 4, value: self.sealedSender)
        try protoWriter.encode(tag: 5, value: self.expireStartDate)
        try protoWriter.encode(tag: 6, value: self.expiresInMs)
        try protoWriter.encode(tag: 7, value: self.revisions)
        try protoWriter.encode(tag: 8, value: self.sms)
        if let directionalDetails = self.directionalDetails {
            try directionalDetails.encode(to: protoWriter)
        }
        if let item = self.item {
            try item.encode(to: protoWriter)
        }
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProtoChatItem : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.chatId = try container.decode(stringEncoded: UInt64.self, forKey: "chatId")
        self.authorId = try container.decode(stringEncoded: UInt64.self, forKey: "authorId")
        self.dateSent = try container.decode(stringEncoded: UInt64.self, forKey: "dateSent")
        self.sealedSender = try container.decode(Bool.self, forKey: "sealedSender")
        self._expireStartDate.wrappedValue = try container.decodeIfPresent(stringEncoded: UInt64.self, forKey: "expireStartDate")
        self._expiresInMs.wrappedValue = try container.decodeIfPresent(stringEncoded: UInt64.self, forKey: "expiresInMs")
        self.revisions = try container.decodeProtoArray(BackupProtoChatItem.self, forKey: "revisions")
        self.sms = try container.decode(Bool.self, forKey: "sms")
        if let incoming = try container.decodeIfPresent(BackupProtoChatItem.BackupProtoIncomingMessageDetails.self, forKey: "incoming") {
            self.directionalDetails = .incoming(incoming)
        } else if let outgoing = try container.decodeIfPresent(BackupProtoChatItem.BackupProtoOutgoingMessageDetails.self, forKey: "outgoing") {
            self.directionalDetails = .outgoing(outgoing)
        } else if let directionless = try container.decodeIfPresent(BackupProtoChatItem.BackupProtoDirectionlessMessageDetails.self, forKey: "directionless") {
            self.directionalDetails = .directionless(directionless)
        } else {
            self.directionalDetails = nil
        }
        if let standardMessage = try container.decodeIfPresent(BackupProtoStandardMessage.self, forKey: "standardMessage") {
            self.item = .standardMessage(standardMessage)
        } else if let contactMessage = try container.decodeIfPresent(BackupProtoContactMessage.self, forKey: "contactMessage") {
            self.item = .contactMessage(contactMessage)
        } else if let voiceMessage = try container.decodeIfPresent(BackupProtoVoiceMessage.self, forKey: "voiceMessage") {
            self.item = .voiceMessage(voiceMessage)
        } else if let stickerMessage = try container.decodeIfPresent(BackupProtoStickerMessage.self, forKey: "stickerMessage") {
            self.item = .stickerMessage(stickerMessage)
        } else if let remoteDeletedMessage = try container.decodeIfPresent(BackupProtoRemoteDeletedMessage.self, forKey: "remoteDeletedMessage") {
            self.item = .remoteDeletedMessage(remoteDeletedMessage)
        } else if let updateMessage = try container.decodeIfPresent(BackupProtoChatUpdateMessage.self, forKey: "updateMessage") {
            self.item = .updateMessage(updateMessage)
        } else {
            self.item = nil
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || self.chatId != 0 {
            try container.encode(stringEncoded: self.chatId, forKey: "chatId")
        }
        if includeDefaults || self.authorId != 0 {
            try container.encode(stringEncoded: self.authorId, forKey: "authorId")
        }
        if includeDefaults || self.dateSent != 0 {
            try container.encode(stringEncoded: self.dateSent, forKey: "dateSent")
        }
        if includeDefaults || self.sealedSender != false {
            try container.encode(self.sealedSender, forKey: "sealedSender")
        }
        try container.encodeIfPresent(stringEncoded: self.expireStartDate, forKey: "expireStartDate")
        try container.encodeIfPresent(stringEncoded: self.expiresInMs, forKey: "expiresInMs")
        if includeDefaults || !self.revisions.isEmpty {
            try container.encodeProtoArray(self.revisions, forKey: "revisions")
        }
        if includeDefaults || self.sms != false {
            try container.encode(self.sms, forKey: "sms")
        }
        switch self.directionalDetails {
        case .incoming(let incoming): try container.encode(incoming, forKey: "incoming")
        case .outgoing(let outgoing): try container.encode(outgoing, forKey: "outgoing")
        case .directionless(let directionless): try container.encode(directionless, forKey: "directionless")
        case Optional.none: break
        }
        switch self.item {
        case .standardMessage(let standardMessage): try container.encode(standardMessage, forKey: "standardMessage")
        case .contactMessage(let contactMessage): try container.encode(contactMessage, forKey: "contactMessage")
        case .voiceMessage(let voiceMessage): try container.encode(voiceMessage, forKey: "voiceMessage")
        case .stickerMessage(let stickerMessage): try container.encode(stickerMessage, forKey: "stickerMessage")
        case .remoteDeletedMessage(let remoteDeletedMessage): try container.encode(remoteDeletedMessage, forKey: "remoteDeletedMessage")
        case .updateMessage(let updateMessage): try container.encode(updateMessage, forKey: "updateMessage")
        case Optional.none: break
        }
    }

}
#endif

/**
 * Subtypes within BackupProtoChatItem
 */
extension BackupProtoChatItem {

    public enum DirectionalDetails {

        case incoming(BackupProtoChatItem.BackupProtoIncomingMessageDetails)
        case outgoing(BackupProtoChatItem.BackupProtoOutgoingMessageDetails)
        case directionless(BackupProtoChatItem.BackupProtoDirectionlessMessageDetails)

        fileprivate func encode(to protoWriter: ProtoWriter) throws {
            switch self {
            case .incoming(let incoming): try protoWriter.encode(tag: 9, value: incoming)
            case .outgoing(let outgoing): try protoWriter.encode(tag: 10, value: outgoing)
            case .directionless(let directionless): try protoWriter.encode(tag: 11, value: directionless)
            }
        }

    }

    public enum Item {

        case standardMessage(BackupProtoStandardMessage)
        case contactMessage(BackupProtoContactMessage)
        case voiceMessage(BackupProtoVoiceMessage)
        case stickerMessage(BackupProtoStickerMessage)
        case remoteDeletedMessage(BackupProtoRemoteDeletedMessage)
        case updateMessage(BackupProtoChatUpdateMessage)

        fileprivate func encode(to protoWriter: ProtoWriter) throws {
            switch self {
            case .standardMessage(let standardMessage): try protoWriter.encode(tag: 13, value: standardMessage)
            case .contactMessage(let contactMessage): try protoWriter.encode(tag: 14, value: contactMessage)
            case .voiceMessage(let voiceMessage): try protoWriter.encode(tag: 15, value: voiceMessage)
            case .stickerMessage(let stickerMessage): try protoWriter.encode(tag: 16, value: stickerMessage)
            case .remoteDeletedMessage(let remoteDeletedMessage): try protoWriter.encode(tag: 17, value: remoteDeletedMessage)
            case .updateMessage(let updateMessage): try protoWriter.encode(tag: 18, value: updateMessage)
            }
        }

    }

    public struct BackupProtoIncomingMessageDetails {

        public var dateReceived: UInt64
        public var dateServerSent: UInt64
        public var read: Bool
        public var unknownFields: UnknownFields = .init()

        public init(
            dateReceived: UInt64,
            dateServerSent: UInt64,
            read: Bool
        ) {
            self.dateReceived = dateReceived
            self.dateServerSent = dateServerSent
            self.read = read
        }

    }

    public struct BackupProtoOutgoingMessageDetails {

        public var sendStatus: [BackupProtoSendStatus] = []
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct BackupProtoDirectionlessMessageDetails {

        public var unknownFields: UnknownFields = .init()

        public init() {
        }

    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoChatItem.DirectionalDetails : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoChatItem.DirectionalDetails : Hashable {
}
#endif

extension BackupProtoChatItem.DirectionalDetails : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoChatItem.Item : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoChatItem.Item : Hashable {
}
#endif

extension BackupProtoChatItem.Item : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoChatItem.BackupProtoIncomingMessageDetails : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoChatItem.BackupProtoIncomingMessageDetails : Hashable {
}
#endif

extension BackupProtoChatItem.BackupProtoIncomingMessageDetails : Sendable {
}

extension BackupProtoChatItem.BackupProtoIncomingMessageDetails : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProtoChatItem.BackupProtoIncomingMessageDetails"
    }

}

extension BackupProtoChatItem.BackupProtoIncomingMessageDetails : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var dateReceived: UInt64 = 0
        var dateServerSent: UInt64 = 0
        var read: Bool = false

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: dateReceived = try protoReader.decode(UInt64.self)
            case 2: dateServerSent = try protoReader.decode(UInt64.self)
            case 3: read = try protoReader.decode(Bool.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.dateReceived = dateReceived
        self.dateServerSent = dateServerSent
        self.read = read
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.dateReceived)
        try protoWriter.encode(tag: 2, value: self.dateServerSent)
        try protoWriter.encode(tag: 3, value: self.read)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProtoChatItem.BackupProtoIncomingMessageDetails : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.dateReceived = try container.decode(stringEncoded: UInt64.self, forKey: "dateReceived")
        self.dateServerSent = try container.decode(stringEncoded: UInt64.self, forKey: "dateServerSent")
        self.read = try container.decode(Bool.self, forKey: "read")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || self.dateReceived != 0 {
            try container.encode(stringEncoded: self.dateReceived, forKey: "dateReceived")
        }
        if includeDefaults || self.dateServerSent != 0 {
            try container.encode(stringEncoded: self.dateServerSent, forKey: "dateServerSent")
        }
        if includeDefaults || self.read != false {
            try container.encode(self.read, forKey: "read")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoChatItem.BackupProtoOutgoingMessageDetails : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoChatItem.BackupProtoOutgoingMessageDetails : Hashable {
}
#endif

extension BackupProtoChatItem.BackupProtoOutgoingMessageDetails : Sendable {
}

extension BackupProtoChatItem.BackupProtoOutgoingMessageDetails : ProtoDefaultedValue {

    public static var defaultedValue: BackupProtoChatItem.BackupProtoOutgoingMessageDetails {
        BackupProtoChatItem.BackupProtoOutgoingMessageDetails()
    }
}

extension BackupProtoChatItem.BackupProtoOutgoingMessageDetails : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProtoChatItem.BackupProtoOutgoingMessageDetails"
    }

}

extension BackupProtoChatItem.BackupProtoOutgoingMessageDetails : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var sendStatus: [BackupProtoSendStatus] = []

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: try protoReader.decode(into: &sendStatus)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.sendStatus = sendStatus
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.sendStatus)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProtoChatItem.BackupProtoOutgoingMessageDetails : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.sendStatus = try container.decodeProtoArray(BackupProtoSendStatus.self, forKey: "sendStatus")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.sendStatus.isEmpty {
            try container.encodeProtoArray(self.sendStatus, forKey: "sendStatus")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoChatItem.BackupProtoDirectionlessMessageDetails : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoChatItem.BackupProtoDirectionlessMessageDetails : Hashable {
}
#endif

extension BackupProtoChatItem.BackupProtoDirectionlessMessageDetails : Sendable {
}

extension BackupProtoChatItem.BackupProtoDirectionlessMessageDetails : ProtoDefaultedValue {

    public static var defaultedValue: BackupProtoChatItem.BackupProtoDirectionlessMessageDetails {
        BackupProtoChatItem.BackupProtoDirectionlessMessageDetails()
    }
}

extension BackupProtoChatItem.BackupProtoDirectionlessMessageDetails : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProtoChatItem.BackupProtoDirectionlessMessageDetails"
    }

}

extension BackupProtoChatItem.BackupProtoDirectionlessMessageDetails : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProtoChatItem.BackupProtoDirectionlessMessageDetails : Codable {

    public enum CodingKeys : CodingKey {
    }

}
#endif
