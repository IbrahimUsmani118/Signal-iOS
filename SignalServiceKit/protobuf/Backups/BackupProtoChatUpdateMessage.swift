//
// Copyright 2024 Signal Messenger, LLC
// SPDX-License-Identifier: AGPL-3.0-only
//

// Code generated by Wire protocol buffer compiler, do not edit.
// Source: BackupProto.BackupProtoChatUpdateMessage in Backup.proto
import Wire

public struct BackupProtoChatUpdateMessage {

    public var update: Update?
    public var unknownFields: UnknownFields = .init()

    public init(configure: (inout Self) -> Swift.Void = { _ in }) {
        configure(&self)
    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoChatUpdateMessage : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoChatUpdateMessage : Hashable {
}
#endif

extension BackupProtoChatUpdateMessage : Sendable {
}

extension BackupProtoChatUpdateMessage : ProtoDefaultedValue {

    public static var defaultedValue: BackupProtoChatUpdateMessage {
        BackupProtoChatUpdateMessage()
    }
}

extension BackupProtoChatUpdateMessage : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProtoChatUpdateMessage"
    }

}

extension BackupProtoChatUpdateMessage : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var update: Update? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: update = .simpleUpdate(try protoReader.decode(BackupProtoSimpleChatUpdate.self))
            case 2: update = .groupChange(try protoReader.decode(BackupProtoGroupChangeChatUpdate.self))
            case 3: update = .expirationTimerChange(try protoReader.decode(BackupProtoExpirationTimerChatUpdate.self))
            case 4: update = .profileChange(try protoReader.decode(BackupProtoProfileChangeChatUpdate.self))
            case 5: update = .threadMerge(try protoReader.decode(BackupProtoThreadMergeChatUpdate.self))
            case 6: update = .sessionSwitchover(try protoReader.decode(BackupProtoSessionSwitchoverChatUpdate.self))
            case 7: update = .callingMessage(try protoReader.decode(BackupProtoCallChatUpdate.self))
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.update = update
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        if let update = self.update {
            try update.encode(to: protoWriter)
        }
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProtoChatUpdateMessage : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        if let simpleUpdate = try container.decodeIfPresent(BackupProtoSimpleChatUpdate.self, forKey: "simpleUpdate") {
            self.update = .simpleUpdate(simpleUpdate)
        } else if let groupChange = try container.decodeIfPresent(BackupProtoGroupChangeChatUpdate.self, forKey: "groupChange") {
            self.update = .groupChange(groupChange)
        } else if let expirationTimerChange = try container.decodeIfPresent(BackupProtoExpirationTimerChatUpdate.self, forKey: "expirationTimerChange") {
            self.update = .expirationTimerChange(expirationTimerChange)
        } else if let profileChange = try container.decodeIfPresent(BackupProtoProfileChangeChatUpdate.self, forKey: "profileChange") {
            self.update = .profileChange(profileChange)
        } else if let threadMerge = try container.decodeIfPresent(BackupProtoThreadMergeChatUpdate.self, forKey: "threadMerge") {
            self.update = .threadMerge(threadMerge)
        } else if let sessionSwitchover = try container.decodeIfPresent(BackupProtoSessionSwitchoverChatUpdate.self, forKey: "sessionSwitchover") {
            self.update = .sessionSwitchover(sessionSwitchover)
        } else if let callingMessage = try container.decodeIfPresent(BackupProtoCallChatUpdate.self, forKey: "callingMessage") {
            self.update = .callingMessage(callingMessage)
        } else {
            self.update = nil
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        switch self.update {
        case .simpleUpdate(let simpleUpdate): try container.encode(simpleUpdate, forKey: "simpleUpdate")
        case .groupChange(let groupChange): try container.encode(groupChange, forKey: "groupChange")
        case .expirationTimerChange(let expirationTimerChange): try container.encode(expirationTimerChange, forKey: "expirationTimerChange")
        case .profileChange(let profileChange): try container.encode(profileChange, forKey: "profileChange")
        case .threadMerge(let threadMerge): try container.encode(threadMerge, forKey: "threadMerge")
        case .sessionSwitchover(let sessionSwitchover): try container.encode(sessionSwitchover, forKey: "sessionSwitchover")
        case .callingMessage(let callingMessage): try container.encode(callingMessage, forKey: "callingMessage")
        case Optional.none: break
        }
    }

}
#endif

/**
 * Subtypes within BackupProtoChatUpdateMessage
 */
extension BackupProtoChatUpdateMessage {

    public enum Update {

        case simpleUpdate(BackupProtoSimpleChatUpdate)
        case groupChange(BackupProtoGroupChangeChatUpdate)
        case expirationTimerChange(BackupProtoExpirationTimerChatUpdate)
        case profileChange(BackupProtoProfileChangeChatUpdate)
        case threadMerge(BackupProtoThreadMergeChatUpdate)
        case sessionSwitchover(BackupProtoSessionSwitchoverChatUpdate)
        case callingMessage(BackupProtoCallChatUpdate)

        fileprivate func encode(to protoWriter: ProtoWriter) throws {
            switch self {
            case .simpleUpdate(let simpleUpdate): try protoWriter.encode(tag: 1, value: simpleUpdate)
            case .groupChange(let groupChange): try protoWriter.encode(tag: 2, value: groupChange)
            case .expirationTimerChange(let expirationTimerChange): try protoWriter.encode(tag: 3, value: expirationTimerChange)
            case .profileChange(let profileChange): try protoWriter.encode(tag: 4, value: profileChange)
            case .threadMerge(let threadMerge): try protoWriter.encode(tag: 5, value: threadMerge)
            case .sessionSwitchover(let sessionSwitchover): try protoWriter.encode(tag: 6, value: sessionSwitchover)
            case .callingMessage(let callingMessage): try protoWriter.encode(tag: 7, value: callingMessage)
            }
        }

    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoChatUpdateMessage.Update : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoChatUpdateMessage.Update : Hashable {
}
#endif

extension BackupProtoChatUpdateMessage.Update : Sendable {
}
