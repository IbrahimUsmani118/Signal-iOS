//
// Copyright 2024 Signal Messenger, LLC
// SPDX-License-Identifier: AGPL-3.0-only
//

// Code generated by Wire protocol buffer compiler, do not edit.
// Source: BackupProto.BackupProtoFilePointer in Backup.proto
import Foundation
import Wire

public struct BackupProtoFilePointer {

    @ProtoDefaulted
    public var key: Foundation.Data?
    @ProtoDefaulted
    public var contentType: String?
    /**
     * Size of fullsize decrypted media blob in bytes.
     * Can be ignored if unset/unavailable.
     */
    @ProtoDefaulted
    public var size: UInt32?
    @ProtoDefaulted
    public var incrementalMac: Foundation.Data?
    @ProtoDefaulted
    public var incrementalMacChunkSize: Foundation.Data?
    @ProtoDefaulted
    public var fileName: String?
    @ProtoDefaulted
    public var flags: UInt32?
    @ProtoDefaulted
    public var width: UInt32?
    @ProtoDefaulted
    public var height: UInt32?
    @ProtoDefaulted
    public var caption: String?
    @ProtoDefaulted
    public var blurHash: String?
    public var locator: Locator?
    public var unknownFields: UnknownFields = .init()

    public init(configure: (inout Self) -> Swift.Void = { _ in }) {
        configure(&self)
    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoFilePointer : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoFilePointer : Hashable {
}
#endif

extension BackupProtoFilePointer : Sendable {
}

extension BackupProtoFilePointer : ProtoDefaultedValue {

    public static var defaultedValue: BackupProtoFilePointer {
        BackupProtoFilePointer()
    }
}

extension BackupProtoFilePointer : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProtoFilePointer"
    }

}

extension BackupProtoFilePointer : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var key: Foundation.Data? = nil
        var contentType: String? = nil
        var size: UInt32? = nil
        var incrementalMac: Foundation.Data? = nil
        var incrementalMacChunkSize: Foundation.Data? = nil
        var fileName: String? = nil
        var flags: UInt32? = nil
        var width: UInt32? = nil
        var height: UInt32? = nil
        var caption: String? = nil
        var blurHash: String? = nil
        var locator: Locator? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 5: key = try protoReader.decode(Foundation.Data.self)
            case 6: contentType = try protoReader.decode(String.self)
            case 7: size = try protoReader.decode(UInt32.self)
            case 8: incrementalMac = try protoReader.decode(Foundation.Data.self)
            case 9: incrementalMacChunkSize = try protoReader.decode(Foundation.Data.self)
            case 10: fileName = try protoReader.decode(String.self)
            case 11: flags = try protoReader.decode(UInt32.self)
            case 12: width = try protoReader.decode(UInt32.self)
            case 13: height = try protoReader.decode(UInt32.self)
            case 14: caption = try protoReader.decode(String.self)
            case 15: blurHash = try protoReader.decode(String.self)
            case 1: locator = .backupLocator(try protoReader.decode(BackupProtoFilePointer.BackupProtoBackupLocator.self))
            case 2: locator = .attachmentLocator(try protoReader.decode(BackupProtoFilePointer.BackupProtoAttachmentLocator.self))
            case 3: locator = .legacyAttachmentLocator(try protoReader.decode(BackupProtoFilePointer.BackupProtoLegacyAttachmentLocator.self))
            case 4: locator = .undownloadedBackupLocator(try protoReader.decode(BackupProtoFilePointer.BackupProtoUndownloadedBackupLocator.self))
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._key.wrappedValue = key
        self._contentType.wrappedValue = contentType
        self._size.wrappedValue = size
        self._incrementalMac.wrappedValue = incrementalMac
        self._incrementalMacChunkSize.wrappedValue = incrementalMacChunkSize
        self._fileName.wrappedValue = fileName
        self._flags.wrappedValue = flags
        self._width.wrappedValue = width
        self._height.wrappedValue = height
        self._caption.wrappedValue = caption
        self._blurHash.wrappedValue = blurHash
        self.locator = locator
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 5, value: self.key)
        try protoWriter.encode(tag: 6, value: self.contentType)
        try protoWriter.encode(tag: 7, value: self.size)
        try protoWriter.encode(tag: 8, value: self.incrementalMac)
        try protoWriter.encode(tag: 9, value: self.incrementalMacChunkSize)
        try protoWriter.encode(tag: 10, value: self.fileName)
        try protoWriter.encode(tag: 11, value: self.flags)
        try protoWriter.encode(tag: 12, value: self.width)
        try protoWriter.encode(tag: 13, value: self.height)
        try protoWriter.encode(tag: 14, value: self.caption)
        try protoWriter.encode(tag: 15, value: self.blurHash)
        if let locator = self.locator {
            try locator.encode(to: protoWriter)
        }
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProtoFilePointer : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._key.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "key")
        self._contentType.wrappedValue = try container.decodeIfPresent(String.self, forKey: "contentType")
        self._size.wrappedValue = try container.decodeIfPresent(UInt32.self, forKey: "size")
        self._incrementalMac.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "incrementalMac")
        self._incrementalMacChunkSize.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "incrementalMacChunkSize")
        self._fileName.wrappedValue = try container.decodeIfPresent(String.self, forKey: "fileName")
        self._flags.wrappedValue = try container.decodeIfPresent(UInt32.self, forKey: "flags")
        self._width.wrappedValue = try container.decodeIfPresent(UInt32.self, forKey: "width")
        self._height.wrappedValue = try container.decodeIfPresent(UInt32.self, forKey: "height")
        self._caption.wrappedValue = try container.decodeIfPresent(String.self, forKey: "caption")
        self._blurHash.wrappedValue = try container.decodeIfPresent(String.self, forKey: "blurHash")
        if let backupLocator = try container.decodeIfPresent(BackupProtoFilePointer.BackupProtoBackupLocator.self, forKey: "backupLocator") {
            self.locator = .backupLocator(backupLocator)
        } else if let attachmentLocator = try container.decodeIfPresent(BackupProtoFilePointer.BackupProtoAttachmentLocator.self, forKey: "attachmentLocator") {
            self.locator = .attachmentLocator(attachmentLocator)
        } else if let legacyAttachmentLocator = try container.decodeIfPresent(BackupProtoFilePointer.BackupProtoLegacyAttachmentLocator.self, forKey: "legacyAttachmentLocator") {
            self.locator = .legacyAttachmentLocator(legacyAttachmentLocator)
        } else if let undownloadedBackupLocator = try container.decodeIfPresent(BackupProtoFilePointer.BackupProtoUndownloadedBackupLocator.self, forKey: "undownloadedBackupLocator") {
            self.locator = .undownloadedBackupLocator(undownloadedBackupLocator)
        } else {
            self.locator = nil
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(stringEncoded: self.key, forKey: "key")
        try container.encodeIfPresent(self.contentType, forKey: "contentType")
        try container.encodeIfPresent(self.size, forKey: "size")
        try container.encodeIfPresent(stringEncoded: self.incrementalMac, forKey: "incrementalMac")
        try container.encodeIfPresent(stringEncoded: self.incrementalMacChunkSize, forKey: "incrementalMacChunkSize")
        try container.encodeIfPresent(self.fileName, forKey: "fileName")
        try container.encodeIfPresent(self.flags, forKey: "flags")
        try container.encodeIfPresent(self.width, forKey: "width")
        try container.encodeIfPresent(self.height, forKey: "height")
        try container.encodeIfPresent(self.caption, forKey: "caption")
        try container.encodeIfPresent(self.blurHash, forKey: "blurHash")
        switch self.locator {
        case .backupLocator(let backupLocator): try container.encode(backupLocator, forKey: "backupLocator")
        case .attachmentLocator(let attachmentLocator): try container.encode(attachmentLocator, forKey: "attachmentLocator")
        case .legacyAttachmentLocator(let legacyAttachmentLocator): try container.encode(legacyAttachmentLocator, forKey: "legacyAttachmentLocator")
        case .undownloadedBackupLocator(let undownloadedBackupLocator): try container.encode(undownloadedBackupLocator, forKey: "undownloadedBackupLocator")
        case Optional.none: break
        }
    }

}
#endif

/**
 * Subtypes within BackupProtoFilePointer
 */
extension BackupProtoFilePointer {

    public enum Locator {

        case backupLocator(BackupProtoFilePointer.BackupProtoBackupLocator)
        case attachmentLocator(BackupProtoFilePointer.BackupProtoAttachmentLocator)
        case legacyAttachmentLocator(BackupProtoFilePointer.BackupProtoLegacyAttachmentLocator)
        case undownloadedBackupLocator(BackupProtoFilePointer.BackupProtoUndownloadedBackupLocator)

        fileprivate func encode(to protoWriter: ProtoWriter) throws {
            switch self {
            case .backupLocator(let backupLocator): try protoWriter.encode(tag: 1, value: backupLocator)
            case .attachmentLocator(let attachmentLocator): try protoWriter.encode(tag: 2, value: attachmentLocator)
            case .legacyAttachmentLocator(let legacyAttachmentLocator): try protoWriter.encode(tag: 3, value: legacyAttachmentLocator)
            case .undownloadedBackupLocator(let undownloadedBackupLocator): try protoWriter.encode(tag: 4, value: undownloadedBackupLocator)
            }
        }

    }

    public struct BackupProtoBackupLocator {

        public var mediaName: String
        public var cdnNumber: UInt32
        public var unknownFields: UnknownFields = .init()

        public init(mediaName: String, cdnNumber: UInt32) {
            self.mediaName = mediaName
            self.cdnNumber = cdnNumber
        }

    }

    public struct BackupProtoAttachmentLocator {

        public var cdnKey: String
        public var cdnNumber: UInt32
        public var uploadTimestamp: UInt64
        public var unknownFields: UnknownFields = .init()

        public init(
            cdnKey: String,
            cdnNumber: UInt32,
            uploadTimestamp: UInt64
        ) {
            self.cdnKey = cdnKey
            self.cdnNumber = cdnNumber
            self.uploadTimestamp = uploadTimestamp
        }

    }

    public struct BackupProtoLegacyAttachmentLocator {

        public var cdnId: UInt64
        public var unknownFields: UnknownFields = .init()

        public init(cdnId: UInt64) {
            self.cdnId = cdnId
        }

    }

    /**
     * An attachment that was backed up without being downloaded.
     * Its MediaName should be generated as “{sender_aci}_{cdn_attachment_key}”,
     * but should eventually transition to a BackupLocator with mediaName
     * being the content hash once it is downloaded.
     */
    public struct BackupProtoUndownloadedBackupLocator {

        public var senderAci: Foundation.Data
        public var cdnKey: String
        public var cdnNumber: UInt32
        public var unknownFields: UnknownFields = .init()

        public init(
            senderAci: Foundation.Data,
            cdnKey: String,
            cdnNumber: UInt32
        ) {
            self.senderAci = senderAci
            self.cdnKey = cdnKey
            self.cdnNumber = cdnNumber
        }

    }

    public enum BackupProtoFlags : Int32, CaseIterable, ProtoEnum, ProtoDefaultedValue {

        case VOICE_MESSAGE = 0
        case BORDERLESS = 1
        case GIF = 2

        public static var defaultedValue: BackupProtoFilePointer.BackupProtoFlags {
            BackupProtoFilePointer.BackupProtoFlags.VOICE_MESSAGE
        }
        public var description: String {
            switch self {
            case .VOICE_MESSAGE: return "VOICE_MESSAGE"
            case .BORDERLESS: return "BORDERLESS"
            case .GIF: return "GIF"
            }
        }

    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoFilePointer.Locator : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoFilePointer.Locator : Hashable {
}
#endif

extension BackupProtoFilePointer.Locator : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoFilePointer.BackupProtoBackupLocator : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoFilePointer.BackupProtoBackupLocator : Hashable {
}
#endif

extension BackupProtoFilePointer.BackupProtoBackupLocator : Sendable {
}

extension BackupProtoFilePointer.BackupProtoBackupLocator : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProtoFilePointer.BackupProtoBackupLocator"
    }

}

extension BackupProtoFilePointer.BackupProtoBackupLocator : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var mediaName: String = ""
        var cdnNumber: UInt32 = 0

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: mediaName = try protoReader.decode(String.self)
            case 2: cdnNumber = try protoReader.decode(UInt32.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.mediaName = mediaName
        self.cdnNumber = cdnNumber
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.mediaName)
        try protoWriter.encode(tag: 2, value: self.cdnNumber)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProtoFilePointer.BackupProtoBackupLocator : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.mediaName = try container.decode(String.self, forKey: "mediaName")
        self.cdnNumber = try container.decode(UInt32.self, forKey: "cdnNumber")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.mediaName.isEmpty {
            try container.encode(self.mediaName, forKey: "mediaName")
        }
        if includeDefaults || self.cdnNumber != 0 {
            try container.encode(self.cdnNumber, forKey: "cdnNumber")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoFilePointer.BackupProtoAttachmentLocator : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoFilePointer.BackupProtoAttachmentLocator : Hashable {
}
#endif

extension BackupProtoFilePointer.BackupProtoAttachmentLocator : Sendable {
}

extension BackupProtoFilePointer.BackupProtoAttachmentLocator : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProtoFilePointer.BackupProtoAttachmentLocator"
    }

}

extension BackupProtoFilePointer.BackupProtoAttachmentLocator : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var cdnKey: String = ""
        var cdnNumber: UInt32 = 0
        var uploadTimestamp: UInt64 = 0

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: cdnKey = try protoReader.decode(String.self)
            case 2: cdnNumber = try protoReader.decode(UInt32.self)
            case 3: uploadTimestamp = try protoReader.decode(UInt64.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.cdnKey = cdnKey
        self.cdnNumber = cdnNumber
        self.uploadTimestamp = uploadTimestamp
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.cdnKey)
        try protoWriter.encode(tag: 2, value: self.cdnNumber)
        try protoWriter.encode(tag: 3, value: self.uploadTimestamp)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProtoFilePointer.BackupProtoAttachmentLocator : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.cdnKey = try container.decode(String.self, forKey: "cdnKey")
        self.cdnNumber = try container.decode(UInt32.self, forKey: "cdnNumber")
        self.uploadTimestamp = try container.decode(stringEncoded: UInt64.self, forKey: "uploadTimestamp")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.cdnKey.isEmpty {
            try container.encode(self.cdnKey, forKey: "cdnKey")
        }
        if includeDefaults || self.cdnNumber != 0 {
            try container.encode(self.cdnNumber, forKey: "cdnNumber")
        }
        if includeDefaults || self.uploadTimestamp != 0 {
            try container.encode(stringEncoded: self.uploadTimestamp, forKey: "uploadTimestamp")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoFilePointer.BackupProtoLegacyAttachmentLocator : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoFilePointer.BackupProtoLegacyAttachmentLocator : Hashable {
}
#endif

extension BackupProtoFilePointer.BackupProtoLegacyAttachmentLocator : Sendable {
}

extension BackupProtoFilePointer.BackupProtoLegacyAttachmentLocator : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProtoFilePointer.BackupProtoLegacyAttachmentLocator"
    }

}

extension BackupProtoFilePointer.BackupProtoLegacyAttachmentLocator : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var cdnId: UInt64 = 0

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: cdnId = try protoReader.decode(UInt64.self, encoding: .fixed)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.cdnId = cdnId
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.cdnId, encoding: .fixed)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProtoFilePointer.BackupProtoLegacyAttachmentLocator : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.cdnId = try container.decode(stringEncoded: UInt64.self, forKey: "cdnId")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || self.cdnId != 0 {
            try container.encode(stringEncoded: self.cdnId, forKey: "cdnId")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoFilePointer.BackupProtoUndownloadedBackupLocator : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoFilePointer.BackupProtoUndownloadedBackupLocator : Hashable {
}
#endif

extension BackupProtoFilePointer.BackupProtoUndownloadedBackupLocator : Sendable {
}

extension BackupProtoFilePointer.BackupProtoUndownloadedBackupLocator : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProtoFilePointer.BackupProtoUndownloadedBackupLocator"
    }

}

extension BackupProtoFilePointer.BackupProtoUndownloadedBackupLocator : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var senderAci: Foundation.Data = .init()
        var cdnKey: String = ""
        var cdnNumber: UInt32 = 0

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: senderAci = try protoReader.decode(Foundation.Data.self)
            case 2: cdnKey = try protoReader.decode(String.self)
            case 3: cdnNumber = try protoReader.decode(UInt32.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.senderAci = senderAci
        self.cdnKey = cdnKey
        self.cdnNumber = cdnNumber
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.senderAci)
        try protoWriter.encode(tag: 2, value: self.cdnKey)
        try protoWriter.encode(tag: 3, value: self.cdnNumber)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProtoFilePointer.BackupProtoUndownloadedBackupLocator : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.senderAci = try container.decode(stringEncoded: Foundation.Data.self, forKey: "senderAci")
        self.cdnKey = try container.decode(String.self, forKey: "cdnKey")
        self.cdnNumber = try container.decode(UInt32.self, forKey: "cdnNumber")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.senderAci.isEmpty {
            try container.encode(stringEncoded: self.senderAci, forKey: "senderAci")
        }
        if includeDefaults || !self.cdnKey.isEmpty {
            try container.encode(self.cdnKey, forKey: "cdnKey")
        }
        if includeDefaults || self.cdnNumber != 0 {
            try container.encode(self.cdnNumber, forKey: "cdnNumber")
        }
    }

}
#endif

extension BackupProtoFilePointer.BackupProtoFlags : Sendable {
}
