//
// Copyright 2024 Signal Messenger, LLC
// SPDX-License-Identifier: AGPL-3.0-only
//

// Code generated by Wire protocol buffer compiler, do not edit.
// Source: BackupProto.BackupProtoQuote in Backup.proto
import Wire

public struct BackupProtoQuote {

    /**
     * null if the target message could not be found at time of quote insert
     */
    @ProtoDefaulted
    public var targetSentTimestamp: UInt64?
    public var authorId: UInt64
    @ProtoDefaulted
    public var text: String?
    public var attachments: [BackupProtoQuote.BackupProtoQuotedAttachment] = []
    public var bodyRanges: [BackupProtoBodyRange] = []
    @ProtoDefaulted
    public var type: BackupProtoQuote.BackupProtoType?
    public var unknownFields: UnknownFields = .init()

    public init(authorId: UInt64, configure: (inout Self) -> Swift.Void = { _ in }) {
        self.authorId = authorId
        configure(&self)
    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoQuote : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoQuote : Hashable {
}
#endif

extension BackupProtoQuote : Sendable {
}

extension BackupProtoQuote : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProtoQuote"
    }

}

extension BackupProtoQuote : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var targetSentTimestamp: UInt64? = nil
        var authorId: UInt64 = 0
        var text: String? = nil
        var attachments: [BackupProtoQuote.BackupProtoQuotedAttachment] = []
        var bodyRanges: [BackupProtoBodyRange] = []
        var type: BackupProtoQuote.BackupProtoType? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: targetSentTimestamp = try protoReader.decode(UInt64.self)
            case 2: authorId = try protoReader.decode(UInt64.self)
            case 3: text = try protoReader.decode(String.self)
            case 4: try protoReader.decode(into: &attachments)
            case 5: try protoReader.decode(into: &bodyRanges)
            case 6: type = try protoReader.decode(BackupProtoQuote.BackupProtoType.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._targetSentTimestamp.wrappedValue = targetSentTimestamp
        self.authorId = authorId
        self._text.wrappedValue = text
        self.attachments = attachments
        self.bodyRanges = bodyRanges
        self._type.wrappedValue = try BackupProtoQuote.BackupProtoType.defaultIfMissing(type)
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.targetSentTimestamp)
        try protoWriter.encode(tag: 2, value: self.authorId)
        try protoWriter.encode(tag: 3, value: self.text)
        try protoWriter.encode(tag: 4, value: self.attachments)
        try protoWriter.encode(tag: 5, value: self.bodyRanges)
        try protoWriter.encode(tag: 6, value: self.type)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProtoQuote : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._targetSentTimestamp.wrappedValue = try container.decodeIfPresent(stringEncoded: UInt64.self, forKey: "targetSentTimestamp")
        self.authorId = try container.decode(stringEncoded: UInt64.self, forKey: "authorId")
        self._text.wrappedValue = try container.decodeIfPresent(String.self, forKey: "text")
        self.attachments = try container.decodeProtoArray(BackupProtoQuote.BackupProtoQuotedAttachment.self, forKey: "attachments")
        self.bodyRanges = try container.decodeProtoArray(BackupProtoBodyRange.self, forKey: "bodyRanges")
        self._type.wrappedValue = try container.decodeIfPresent(BackupProtoQuote.BackupProtoType.self, forKey: "type")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        try container.encodeIfPresent(stringEncoded: self.targetSentTimestamp, forKey: "targetSentTimestamp")
        if includeDefaults || self.authorId != 0 {
            try container.encode(stringEncoded: self.authorId, forKey: "authorId")
        }
        try container.encodeIfPresent(self.text, forKey: "text")
        if includeDefaults || !self.attachments.isEmpty {
            try container.encodeProtoArray(self.attachments, forKey: "attachments")
        }
        if includeDefaults || !self.bodyRanges.isEmpty {
            try container.encodeProtoArray(self.bodyRanges, forKey: "bodyRanges")
        }
        try container.encodeIfPresent(self.type, forKey: "type")
    }

}
#endif

/**
 * Subtypes within BackupProtoQuote
 */
extension BackupProtoQuote {

    public enum BackupProtoType : Int32, CaseIterable, ProtoEnum, ProtoDefaultedValue {

        case UNKNOWN = 0
        case NORMAL = 1
        case GIFTBADGE = 2

        public static var defaultedValue: BackupProtoQuote.BackupProtoType {
            BackupProtoQuote.BackupProtoType.UNKNOWN
        }
        public var description: String {
            switch self {
            case .UNKNOWN: return "UNKNOWN"
            case .NORMAL: return "NORMAL"
            case .GIFTBADGE: return "GIFTBADGE"
            }
        }

    }

    public struct BackupProtoQuotedAttachment {

        @ProtoDefaulted
        public var contentType: String?
        @ProtoDefaulted
        public var fileName: String?
        @ProtoDefaulted
        public var thumbnail: BackupProtoFilePointer?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

}

extension BackupProtoQuote.BackupProtoType : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoQuote.BackupProtoQuotedAttachment : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoQuote.BackupProtoQuotedAttachment : Hashable {
}
#endif

extension BackupProtoQuote.BackupProtoQuotedAttachment : Sendable {
}

extension BackupProtoQuote.BackupProtoQuotedAttachment : ProtoDefaultedValue {

    public static var defaultedValue: BackupProtoQuote.BackupProtoQuotedAttachment {
        BackupProtoQuote.BackupProtoQuotedAttachment()
    }
}

extension BackupProtoQuote.BackupProtoQuotedAttachment : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProtoQuote.BackupProtoQuotedAttachment"
    }

}

extension BackupProtoQuote.BackupProtoQuotedAttachment : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var contentType: String? = nil
        var fileName: String? = nil
        var thumbnail: BackupProtoFilePointer? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: contentType = try protoReader.decode(String.self)
            case 2: fileName = try protoReader.decode(String.self)
            case 3: thumbnail = try protoReader.decode(BackupProtoFilePointer.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._contentType.wrappedValue = contentType
        self._fileName.wrappedValue = fileName
        self._thumbnail.wrappedValue = thumbnail
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.contentType)
        try protoWriter.encode(tag: 2, value: self.fileName)
        try protoWriter.encode(tag: 3, value: self.thumbnail)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProtoQuote.BackupProtoQuotedAttachment : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._contentType.wrappedValue = try container.decodeIfPresent(String.self, forKey: "contentType")
        self._fileName.wrappedValue = try container.decodeIfPresent(String.self, forKey: "fileName")
        self._thumbnail.wrappedValue = try container.decodeIfPresent(BackupProtoFilePointer.self, forKey: "thumbnail")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(self.contentType, forKey: "contentType")
        try container.encodeIfPresent(self.fileName, forKey: "fileName")
        try container.encodeIfPresent(self.thumbnail, forKey: "thumbnail")
    }

}
#endif
