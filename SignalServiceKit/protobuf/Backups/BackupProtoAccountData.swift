//
// Copyright 2024 Signal Messenger, LLC
// SPDX-License-Identifier: AGPL-3.0-only
//

// Code generated by Wire protocol buffer compiler, do not edit.
// Source: BackupProto.BackupProtoAccountData in Backup.proto
import Foundation
import Wire

public struct BackupProtoAccountData {

    public var profileKey: Foundation.Data
    @ProtoDefaulted
    public var username: String?
    public var usernameLink: BackupProtoAccountData.BackupProtoUsernameLink?
    public var givenName: String
    public var familyName: String
    public var avatarUrlPath: String
    public var subscriberId: Foundation.Data
    public var subscriberCurrencyCode: String
    public var subscriptionManuallyCancelled: Bool
    public var accountSettings: BackupProtoAccountData.BackupProtoAccountSettings?
    public var unknownFields: UnknownFields = .init()

    public init(
        profileKey: Foundation.Data,
        givenName: String,
        familyName: String,
        avatarUrlPath: String,
        subscriberId: Foundation.Data,
        subscriberCurrencyCode: String,
        subscriptionManuallyCancelled: Bool,
        configure: (inout Self) -> Swift.Void = { _ in }
    ) {
        self.profileKey = profileKey
        self.givenName = givenName
        self.familyName = familyName
        self.avatarUrlPath = avatarUrlPath
        self.subscriberId = subscriberId
        self.subscriberCurrencyCode = subscriberCurrencyCode
        self.subscriptionManuallyCancelled = subscriptionManuallyCancelled
        configure(&self)
    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoAccountData : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoAccountData : Hashable {
}
#endif

extension BackupProtoAccountData : Sendable {
}

extension BackupProtoAccountData : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProtoAccountData"
    }

}

extension BackupProtoAccountData : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var profileKey: Foundation.Data = .init()
        var username: String? = nil
        var usernameLink: BackupProtoAccountData.BackupProtoUsernameLink? = nil
        var givenName: String = ""
        var familyName: String = ""
        var avatarUrlPath: String = ""
        var subscriberId: Foundation.Data = .init()
        var subscriberCurrencyCode: String = ""
        var subscriptionManuallyCancelled: Bool = false
        var accountSettings: BackupProtoAccountData.BackupProtoAccountSettings? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: profileKey = try protoReader.decode(Foundation.Data.self)
            case 2: username = try protoReader.decode(String.self)
            case 3: usernameLink = try protoReader.decode(BackupProtoAccountData.BackupProtoUsernameLink.self)
            case 4: givenName = try protoReader.decode(String.self)
            case 5: familyName = try protoReader.decode(String.self)
            case 6: avatarUrlPath = try protoReader.decode(String.self)
            case 7: subscriberId = try protoReader.decode(Foundation.Data.self)
            case 8: subscriberCurrencyCode = try protoReader.decode(String.self)
            case 9: subscriptionManuallyCancelled = try protoReader.decode(Bool.self)
            case 10: accountSettings = try protoReader.decode(BackupProtoAccountData.BackupProtoAccountSettings.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.profileKey = profileKey
        self._username.wrappedValue = username
        self.usernameLink = usernameLink
        self.givenName = givenName
        self.familyName = familyName
        self.avatarUrlPath = avatarUrlPath
        self.subscriberId = subscriberId
        self.subscriberCurrencyCode = subscriberCurrencyCode
        self.subscriptionManuallyCancelled = subscriptionManuallyCancelled
        self.accountSettings = accountSettings
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.profileKey)
        try protoWriter.encode(tag: 2, value: self.username)
        try protoWriter.encode(tag: 3, value: self.usernameLink)
        try protoWriter.encode(tag: 4, value: self.givenName)
        try protoWriter.encode(tag: 5, value: self.familyName)
        try protoWriter.encode(tag: 6, value: self.avatarUrlPath)
        try protoWriter.encode(tag: 7, value: self.subscriberId)
        try protoWriter.encode(tag: 8, value: self.subscriberCurrencyCode)
        try protoWriter.encode(tag: 9, value: self.subscriptionManuallyCancelled)
        try protoWriter.encode(tag: 10, value: self.accountSettings)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProtoAccountData : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.profileKey = try container.decode(stringEncoded: Foundation.Data.self, forKey: "profileKey")
        self._username.wrappedValue = try container.decodeIfPresent(String.self, forKey: "username")
        self.usernameLink = try container.decodeIfPresent(BackupProtoAccountData.BackupProtoUsernameLink.self, forKey: "usernameLink")
        self.givenName = try container.decode(String.self, forKey: "givenName")
        self.familyName = try container.decode(String.self, forKey: "familyName")
        self.avatarUrlPath = try container.decode(String.self, forKey: "avatarUrlPath")
        self.subscriberId = try container.decode(stringEncoded: Foundation.Data.self, forKey: "subscriberId")
        self.subscriberCurrencyCode = try container.decode(String.self, forKey: "subscriberCurrencyCode")
        self.subscriptionManuallyCancelled = try container.decode(Bool.self, forKey: "subscriptionManuallyCancelled")
        self.accountSettings = try container.decodeIfPresent(BackupProtoAccountData.BackupProtoAccountSettings.self, forKey: "accountSettings")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.profileKey.isEmpty {
            try container.encode(stringEncoded: self.profileKey, forKey: "profileKey")
        }
        try container.encodeIfPresent(self.username, forKey: "username")
        try container.encodeIfPresent(self.usernameLink, forKey: "usernameLink")
        if includeDefaults || !self.givenName.isEmpty {
            try container.encode(self.givenName, forKey: "givenName")
        }
        if includeDefaults || !self.familyName.isEmpty {
            try container.encode(self.familyName, forKey: "familyName")
        }
        if includeDefaults || !self.avatarUrlPath.isEmpty {
            try container.encode(self.avatarUrlPath, forKey: "avatarUrlPath")
        }
        if includeDefaults || !self.subscriberId.isEmpty {
            try container.encode(stringEncoded: self.subscriberId, forKey: "subscriberId")
        }
        if includeDefaults || !self.subscriberCurrencyCode.isEmpty {
            try container.encode(self.subscriberCurrencyCode, forKey: "subscriberCurrencyCode")
        }
        if includeDefaults || self.subscriptionManuallyCancelled != false {
            try container.encode(self.subscriptionManuallyCancelled, forKey: "subscriptionManuallyCancelled")
        }
        try container.encodeIfPresent(self.accountSettings, forKey: "accountSettings")
    }

}
#endif

/**
 * Subtypes within BackupProtoAccountData
 */
extension BackupProtoAccountData {

    public enum BackupProtoPhoneNumberSharingMode : Int32, CaseIterable, ProtoEnum,
            ProtoDefaultedValue {

        case UNKNOWN = 0
        case EVERYBODY = 1
        case NOBODY = 2

        public static var defaultedValue: BackupProtoAccountData.BackupProtoPhoneNumberSharingMode {
            BackupProtoAccountData.BackupProtoPhoneNumberSharingMode.UNKNOWN
        }
        public var description: String {
            switch self {
            case .UNKNOWN: return "UNKNOWN"
            case .EVERYBODY: return "EVERYBODY"
            case .NOBODY: return "NOBODY"
            }
        }

    }

    public struct BackupProtoUsernameLink {

        /**
         * 32 bytes of entropy used for encryption
         */
        public var entropy: Foundation.Data
        /**
         * 16 bytes of encoded UUID provided by the server
         */
        public var serverId: Foundation.Data
        @ProtoDefaulted
        public var color: BackupProtoAccountData.BackupProtoUsernameLink.BackupProtoColor?
        public var unknownFields: UnknownFields = .init()

        public init(
            entropy: Foundation.Data,
            serverId: Foundation.Data,
            configure: (inout Self) -> Swift.Void = { _ in }
        ) {
            self.entropy = entropy
            self.serverId = serverId
            configure(&self)
        }

    }

    @dynamicMemberLookup
    public struct BackupProtoAccountSettings {

        @CopyOnWrite
        private var storage: BackupProtoAccountData.BackupProtoAccountSettings.Storage
        /**
         * Access the underlying storage
         */
        public subscript<Property>(dynamicMember keyPath: WritableKeyPath<BackupProtoAccountData.BackupProtoAccountSettings.Storage, Property>) -> Property {
            get {
                storage[keyPath: keyPath]
            }
            set {
                storage[keyPath: keyPath] = newValue
            }
        }
        public var readReceipts: Bool {
            get {
                storage.readReceipts
            }
            set {
                storage.readReceipts = newValue
            }
        }
        public var sealedSenderIndicators: Bool {
            get {
                storage.sealedSenderIndicators
            }
            set {
                storage.sealedSenderIndicators = newValue
            }
        }
        public var typingIndicators: Bool {
            get {
                storage.typingIndicators
            }
            set {
                storage.typingIndicators = newValue
            }
        }
        public var linkPreviews: Bool {
            get {
                storage.linkPreviews
            }
            set {
                storage.linkPreviews = newValue
            }
        }
        public var notDiscoverableByPhoneNumber: Bool {
            get {
                storage.notDiscoverableByPhoneNumber
            }
            set {
                storage.notDiscoverableByPhoneNumber = newValue
            }
        }
        public var preferContactAvatars: Bool {
            get {
                storage.preferContactAvatars
            }
            set {
                storage.preferContactAvatars = newValue
            }
        }
        /**
         * 0 means no universal expire timer.
         */
        public var universalExpireTimer: UInt32 {
            get {
                storage.universalExpireTimer
            }
            set {
                storage.universalExpireTimer = newValue
            }
        }
        public var preferredReactionEmoji: [String] {
            get {
                storage.preferredReactionEmoji
            }
            set {
                storage.preferredReactionEmoji = newValue
            }
        }
        public var displayBadgesOnProfile: Bool {
            get {
                storage.displayBadgesOnProfile
            }
            set {
                storage.displayBadgesOnProfile = newValue
            }
        }
        public var keepMutedChatsArchived: Bool {
            get {
                storage.keepMutedChatsArchived
            }
            set {
                storage.keepMutedChatsArchived = newValue
            }
        }
        public var hasSetMyStoriesPrivacy: Bool {
            get {
                storage.hasSetMyStoriesPrivacy
            }
            set {
                storage.hasSetMyStoriesPrivacy = newValue
            }
        }
        public var hasViewedOnboardingStory: Bool {
            get {
                storage.hasViewedOnboardingStory
            }
            set {
                storage.hasViewedOnboardingStory = newValue
            }
        }
        public var storiesDisabled: Bool {
            get {
                storage.storiesDisabled
            }
            set {
                storage.storiesDisabled = newValue
            }
        }
        public var storyViewReceiptsEnabled: Bool? {
            get {
                storage.storyViewReceiptsEnabled
            }
            set {
                storage.storyViewReceiptsEnabled = newValue
            }
        }
        public var hasSeenGroupStoryEducationSheet: Bool {
            get {
                storage.hasSeenGroupStoryEducationSheet
            }
            set {
                storage.hasSeenGroupStoryEducationSheet = newValue
            }
        }
        public var hasCompletedUsernameOnboarding: Bool {
            get {
                storage.hasCompletedUsernameOnboarding
            }
            set {
                storage.hasCompletedUsernameOnboarding = newValue
            }
        }
        public var phoneNumberSharingMode: BackupProtoAccountData.BackupProtoPhoneNumberSharingMode? {
            get {
                storage.phoneNumberSharingMode
            }
            set {
                storage.phoneNumberSharingMode = newValue
            }
        }
        public var unknownFields: UnknownFields {
            get {
                storage.unknownFields
            }
            set {
                storage.unknownFields = newValue
            }
        }

        public init(
            readReceipts: Bool,
            sealedSenderIndicators: Bool,
            typingIndicators: Bool,
            linkPreviews: Bool,
            notDiscoverableByPhoneNumber: Bool,
            preferContactAvatars: Bool,
            universalExpireTimer: UInt32,
            displayBadgesOnProfile: Bool,
            keepMutedChatsArchived: Bool,
            hasSetMyStoriesPrivacy: Bool,
            hasViewedOnboardingStory: Bool,
            storiesDisabled: Bool,
            hasSeenGroupStoryEducationSheet: Bool,
            hasCompletedUsernameOnboarding: Bool,
            configure: (inout Self.Storage) -> Swift.Void = { _ in }
        ) {
            self.storage = BackupProtoAccountData.BackupProtoAccountSettings.Storage(
                    readReceipts: readReceipts,
                    sealedSenderIndicators: sealedSenderIndicators,
                    typingIndicators: typingIndicators,
                    linkPreviews: linkPreviews,
                    notDiscoverableByPhoneNumber: notDiscoverableByPhoneNumber,
                    preferContactAvatars: preferContactAvatars,
                    universalExpireTimer: universalExpireTimer,
                    displayBadgesOnProfile: displayBadgesOnProfile,
                    keepMutedChatsArchived: keepMutedChatsArchived,
                    hasSetMyStoriesPrivacy: hasSetMyStoriesPrivacy,
                    hasViewedOnboardingStory: hasViewedOnboardingStory,
                    storiesDisabled: storiesDisabled,
                    hasSeenGroupStoryEducationSheet: hasSeenGroupStoryEducationSheet,
                    hasCompletedUsernameOnboarding: hasCompletedUsernameOnboarding,
                    configure: configure
                    )
        }

    }

}

extension BackupProtoAccountData.BackupProtoPhoneNumberSharingMode : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoAccountData.BackupProtoUsernameLink : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoAccountData.BackupProtoUsernameLink : Hashable {
}
#endif

extension BackupProtoAccountData.BackupProtoUsernameLink : Sendable {
}

extension BackupProtoAccountData.BackupProtoUsernameLink : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProtoAccountData.BackupProtoUsernameLink"
    }

}

extension BackupProtoAccountData.BackupProtoUsernameLink : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var entropy: Foundation.Data = .init()
        var serverId: Foundation.Data = .init()
        var color: BackupProtoAccountData.BackupProtoUsernameLink.BackupProtoColor? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: entropy = try protoReader.decode(Foundation.Data.self)
            case 2: serverId = try protoReader.decode(Foundation.Data.self)
            case 3: color = try protoReader.decode(BackupProtoAccountData.BackupProtoUsernameLink.BackupProtoColor.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.entropy = entropy
        self.serverId = serverId
        self._color.wrappedValue = try BackupProtoAccountData.BackupProtoUsernameLink.BackupProtoColor.defaultIfMissing(color)
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.entropy)
        try protoWriter.encode(tag: 2, value: self.serverId)
        try protoWriter.encode(tag: 3, value: self.color)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProtoAccountData.BackupProtoUsernameLink : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.entropy = try container.decode(stringEncoded: Foundation.Data.self, forKey: "entropy")
        self.serverId = try container.decode(stringEncoded: Foundation.Data.self, forKey: "serverId")
        self._color.wrappedValue = try container.decodeIfPresent(BackupProtoAccountData.BackupProtoUsernameLink.BackupProtoColor.self, forKey: "color")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.entropy.isEmpty {
            try container.encode(stringEncoded: self.entropy, forKey: "entropy")
        }
        if includeDefaults || !self.serverId.isEmpty {
            try container.encode(stringEncoded: self.serverId, forKey: "serverId")
        }
        try container.encodeIfPresent(self.color, forKey: "color")
    }

}
#endif

/**
 * Subtypes within BackupProtoAccountData.BackupProtoUsernameLink
 */
extension BackupProtoAccountData.BackupProtoUsernameLink {

    public enum BackupProtoColor : Int32, CaseIterable, ProtoEnum, ProtoDefaultedValue {

        case UNKNOWN = 0
        case BLUE = 1
        case WHITE = 2
        case GREY = 3
        case OLIVE = 4
        case GREEN = 5
        case ORANGE = 6
        case PINK = 7
        case PURPLE = 8

        public static var defaultedValue: BackupProtoAccountData.BackupProtoUsernameLink.BackupProtoColor {
            BackupProtoAccountData.BackupProtoUsernameLink.BackupProtoColor.UNKNOWN
        }
        public var description: String {
            switch self {
            case .UNKNOWN: return "UNKNOWN"
            case .BLUE: return "BLUE"
            case .WHITE: return "WHITE"
            case .GREY: return "GREY"
            case .OLIVE: return "OLIVE"
            case .GREEN: return "GREEN"
            case .ORANGE: return "ORANGE"
            case .PINK: return "PINK"
            case .PURPLE: return "PURPLE"
            }
        }

    }

}

extension BackupProtoAccountData.BackupProtoUsernameLink.BackupProtoColor : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoAccountData.BackupProtoAccountSettings : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoAccountData.BackupProtoAccountSettings : Hashable {
}
#endif

extension BackupProtoAccountData.BackupProtoAccountSettings : Sendable {
}

extension BackupProtoAccountData.BackupProtoAccountSettings : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        self.storage = try BackupProtoAccountData.BackupProtoAccountSettings.Storage(from: protoReader)
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try storage.encode(to: protoWriter)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProtoAccountData.BackupProtoAccountSettings : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        self.storage = try container.decode(BackupProtoAccountData.BackupProtoAccountSettings.Storage.self)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(storage)
    }

}
#endif

extension BackupProtoAccountData.BackupProtoAccountSettings {

    /**
     * Underlying storage for BackupProtoAccountData.BackupProtoAccountSettings
     */
    public struct Storage {

        public var readReceipts: Bool
        public var sealedSenderIndicators: Bool
        public var typingIndicators: Bool
        public var linkPreviews: Bool
        public var notDiscoverableByPhoneNumber: Bool
        public var preferContactAvatars: Bool
        public var universalExpireTimer: UInt32
        public var preferredReactionEmoji: [String] = []
        public var displayBadgesOnProfile: Bool
        public var keepMutedChatsArchived: Bool
        public var hasSetMyStoriesPrivacy: Bool
        public var hasViewedOnboardingStory: Bool
        public var storiesDisabled: Bool
        @ProtoDefaulted
        public var storyViewReceiptsEnabled: Bool?
        public var hasSeenGroupStoryEducationSheet: Bool
        public var hasCompletedUsernameOnboarding: Bool
        @ProtoDefaulted
        public var phoneNumberSharingMode: BackupProtoAccountData.BackupProtoPhoneNumberSharingMode?
        public var unknownFields: UnknownFields = .init()

        public init(
            readReceipts: Bool,
            sealedSenderIndicators: Bool,
            typingIndicators: Bool,
            linkPreviews: Bool,
            notDiscoverableByPhoneNumber: Bool,
            preferContactAvatars: Bool,
            universalExpireTimer: UInt32,
            displayBadgesOnProfile: Bool,
            keepMutedChatsArchived: Bool,
            hasSetMyStoriesPrivacy: Bool,
            hasViewedOnboardingStory: Bool,
            storiesDisabled: Bool,
            hasSeenGroupStoryEducationSheet: Bool,
            hasCompletedUsernameOnboarding: Bool,
            configure: (inout Self) -> Swift.Void = { _ in }
        ) {
            self.readReceipts = readReceipts
            self.sealedSenderIndicators = sealedSenderIndicators
            self.typingIndicators = typingIndicators
            self.linkPreviews = linkPreviews
            self.notDiscoverableByPhoneNumber = notDiscoverableByPhoneNumber
            self.preferContactAvatars = preferContactAvatars
            self.universalExpireTimer = universalExpireTimer
            self.displayBadgesOnProfile = displayBadgesOnProfile
            self.keepMutedChatsArchived = keepMutedChatsArchived
            self.hasSetMyStoriesPrivacy = hasSetMyStoriesPrivacy
            self.hasViewedOnboardingStory = hasViewedOnboardingStory
            self.storiesDisabled = storiesDisabled
            self.hasSeenGroupStoryEducationSheet = hasSeenGroupStoryEducationSheet
            self.hasCompletedUsernameOnboarding = hasCompletedUsernameOnboarding
            configure(&self)
        }

    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProtoAccountData.BackupProtoAccountSettings.Storage : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProtoAccountData.BackupProtoAccountSettings.Storage : Hashable {
}
#endif

extension BackupProtoAccountData.BackupProtoAccountSettings.Storage : Sendable {
}

extension BackupProtoAccountData.BackupProtoAccountSettings.Storage : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProtoAccountData.BackupProtoAccountSettings"
    }

}

extension BackupProtoAccountData.BackupProtoAccountSettings.Storage : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var readReceipts: Bool = false
        var sealedSenderIndicators: Bool = false
        var typingIndicators: Bool = false
        var linkPreviews: Bool = false
        var notDiscoverableByPhoneNumber: Bool = false
        var preferContactAvatars: Bool = false
        var universalExpireTimer: UInt32 = 0
        var preferredReactionEmoji: [String] = []
        var displayBadgesOnProfile: Bool = false
        var keepMutedChatsArchived: Bool = false
        var hasSetMyStoriesPrivacy: Bool = false
        var hasViewedOnboardingStory: Bool = false
        var storiesDisabled: Bool = false
        var storyViewReceiptsEnabled: Bool? = nil
        var hasSeenGroupStoryEducationSheet: Bool = false
        var hasCompletedUsernameOnboarding: Bool = false
        var phoneNumberSharingMode: BackupProtoAccountData.BackupProtoPhoneNumberSharingMode? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: readReceipts = try protoReader.decode(Bool.self)
            case 2: sealedSenderIndicators = try protoReader.decode(Bool.self)
            case 3: typingIndicators = try protoReader.decode(Bool.self)
            case 4: linkPreviews = try protoReader.decode(Bool.self)
            case 5: notDiscoverableByPhoneNumber = try protoReader.decode(Bool.self)
            case 6: preferContactAvatars = try protoReader.decode(Bool.self)
            case 7: universalExpireTimer = try protoReader.decode(UInt32.self)
            case 8: try protoReader.decode(into: &preferredReactionEmoji)
            case 9: displayBadgesOnProfile = try protoReader.decode(Bool.self)
            case 10: keepMutedChatsArchived = try protoReader.decode(Bool.self)
            case 11: hasSetMyStoriesPrivacy = try protoReader.decode(Bool.self)
            case 12: hasViewedOnboardingStory = try protoReader.decode(Bool.self)
            case 13: storiesDisabled = try protoReader.decode(Bool.self)
            case 14: storyViewReceiptsEnabled = try protoReader.decode(Bool.self)
            case 15: hasSeenGroupStoryEducationSheet = try protoReader.decode(Bool.self)
            case 16: hasCompletedUsernameOnboarding = try protoReader.decode(Bool.self)
            case 17: phoneNumberSharingMode = try protoReader.decode(BackupProtoAccountData.BackupProtoPhoneNumberSharingMode.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.readReceipts = readReceipts
        self.sealedSenderIndicators = sealedSenderIndicators
        self.typingIndicators = typingIndicators
        self.linkPreviews = linkPreviews
        self.notDiscoverableByPhoneNumber = notDiscoverableByPhoneNumber
        self.preferContactAvatars = preferContactAvatars
        self.universalExpireTimer = universalExpireTimer
        self.preferredReactionEmoji = preferredReactionEmoji
        self.displayBadgesOnProfile = displayBadgesOnProfile
        self.keepMutedChatsArchived = keepMutedChatsArchived
        self.hasSetMyStoriesPrivacy = hasSetMyStoriesPrivacy
        self.hasViewedOnboardingStory = hasViewedOnboardingStory
        self.storiesDisabled = storiesDisabled
        self._storyViewReceiptsEnabled.wrappedValue = storyViewReceiptsEnabled
        self.hasSeenGroupStoryEducationSheet = hasSeenGroupStoryEducationSheet
        self.hasCompletedUsernameOnboarding = hasCompletedUsernameOnboarding
        self._phoneNumberSharingMode.wrappedValue = try BackupProtoAccountData.BackupProtoPhoneNumberSharingMode.defaultIfMissing(phoneNumberSharingMode)
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.readReceipts)
        try protoWriter.encode(tag: 2, value: self.sealedSenderIndicators)
        try protoWriter.encode(tag: 3, value: self.typingIndicators)
        try protoWriter.encode(tag: 4, value: self.linkPreviews)
        try protoWriter.encode(tag: 5, value: self.notDiscoverableByPhoneNumber)
        try protoWriter.encode(tag: 6, value: self.preferContactAvatars)
        try protoWriter.encode(tag: 7, value: self.universalExpireTimer)
        try protoWriter.encode(tag: 8, value: self.preferredReactionEmoji)
        try protoWriter.encode(tag: 9, value: self.displayBadgesOnProfile)
        try protoWriter.encode(tag: 10, value: self.keepMutedChatsArchived)
        try protoWriter.encode(tag: 11, value: self.hasSetMyStoriesPrivacy)
        try protoWriter.encode(tag: 12, value: self.hasViewedOnboardingStory)
        try protoWriter.encode(tag: 13, value: self.storiesDisabled)
        try protoWriter.encode(tag: 14, value: self.storyViewReceiptsEnabled)
        try protoWriter.encode(tag: 15, value: self.hasSeenGroupStoryEducationSheet)
        try protoWriter.encode(tag: 16, value: self.hasCompletedUsernameOnboarding)
        try protoWriter.encode(tag: 17, value: self.phoneNumberSharingMode)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProtoAccountData.BackupProtoAccountSettings.Storage : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.readReceipts = try container.decode(Bool.self, forKey: "readReceipts")
        self.sealedSenderIndicators = try container.decode(Bool.self, forKey: "sealedSenderIndicators")
        self.typingIndicators = try container.decode(Bool.self, forKey: "typingIndicators")
        self.linkPreviews = try container.decode(Bool.self, forKey: "linkPreviews")
        self.notDiscoverableByPhoneNumber = try container.decode(Bool.self, forKey: "notDiscoverableByPhoneNumber")
        self.preferContactAvatars = try container.decode(Bool.self, forKey: "preferContactAvatars")
        self.universalExpireTimer = try container.decode(UInt32.self, forKey: "universalExpireTimer")
        self.preferredReactionEmoji = try container.decodeProtoArray(String.self, forKey: "preferredReactionEmoji")
        self.displayBadgesOnProfile = try container.decode(Bool.self, forKey: "displayBadgesOnProfile")
        self.keepMutedChatsArchived = try container.decode(Bool.self, forKey: "keepMutedChatsArchived")
        self.hasSetMyStoriesPrivacy = try container.decode(Bool.self, forKey: "hasSetMyStoriesPrivacy")
        self.hasViewedOnboardingStory = try container.decode(Bool.self, forKey: "hasViewedOnboardingStory")
        self.storiesDisabled = try container.decode(Bool.self, forKey: "storiesDisabled")
        self._storyViewReceiptsEnabled.wrappedValue = try container.decodeIfPresent(Bool.self, forKey: "storyViewReceiptsEnabled")
        self.hasSeenGroupStoryEducationSheet = try container.decode(Bool.self, forKey: "hasSeenGroupStoryEducationSheet")
        self.hasCompletedUsernameOnboarding = try container.decode(Bool.self, forKey: "hasCompletedUsernameOnboarding")
        self._phoneNumberSharingMode.wrappedValue = try container.decodeIfPresent(BackupProtoAccountData.BackupProtoPhoneNumberSharingMode.self, forKey: "phoneNumberSharingMode")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || self.readReceipts != false {
            try container.encode(self.readReceipts, forKey: "readReceipts")
        }
        if includeDefaults || self.sealedSenderIndicators != false {
            try container.encode(self.sealedSenderIndicators, forKey: "sealedSenderIndicators")
        }
        if includeDefaults || self.typingIndicators != false {
            try container.encode(self.typingIndicators, forKey: "typingIndicators")
        }
        if includeDefaults || self.linkPreviews != false {
            try container.encode(self.linkPreviews, forKey: "linkPreviews")
        }
        if includeDefaults || self.notDiscoverableByPhoneNumber != false {
            try container.encode(self.notDiscoverableByPhoneNumber, forKey: "notDiscoverableByPhoneNumber")
        }
        if includeDefaults || self.preferContactAvatars != false {
            try container.encode(self.preferContactAvatars, forKey: "preferContactAvatars")
        }
        if includeDefaults || self.universalExpireTimer != 0 {
            try container.encode(self.universalExpireTimer, forKey: "universalExpireTimer")
        }
        if includeDefaults || !self.preferredReactionEmoji.isEmpty {
            try container.encodeProtoArray(self.preferredReactionEmoji, forKey: "preferredReactionEmoji")
        }
        if includeDefaults || self.displayBadgesOnProfile != false {
            try container.encode(self.displayBadgesOnProfile, forKey: "displayBadgesOnProfile")
        }
        if includeDefaults || self.keepMutedChatsArchived != false {
            try container.encode(self.keepMutedChatsArchived, forKey: "keepMutedChatsArchived")
        }
        if includeDefaults || self.hasSetMyStoriesPrivacy != false {
            try container.encode(self.hasSetMyStoriesPrivacy, forKey: "hasSetMyStoriesPrivacy")
        }
        if includeDefaults || self.hasViewedOnboardingStory != false {
            try container.encode(self.hasViewedOnboardingStory, forKey: "hasViewedOnboardingStory")
        }
        if includeDefaults || self.storiesDisabled != false {
            try container.encode(self.storiesDisabled, forKey: "storiesDisabled")
        }
        try container.encodeIfPresent(self.storyViewReceiptsEnabled, forKey: "storyViewReceiptsEnabled")
        if includeDefaults || self.hasSeenGroupStoryEducationSheet != false {
            try container.encode(self.hasSeenGroupStoryEducationSheet, forKey: "hasSeenGroupStoryEducationSheet")
        }
        if includeDefaults || self.hasCompletedUsernameOnboarding != false {
            try container.encode(self.hasCompletedUsernameOnboarding, forKey: "hasCompletedUsernameOnboarding")
        }
        try container.encodeIfPresent(self.phoneNumberSharingMode, forKey: "phoneNumberSharingMode")
    }

}
#endif
