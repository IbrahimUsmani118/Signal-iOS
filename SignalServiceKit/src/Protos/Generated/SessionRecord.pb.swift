// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: SessionRecord.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
//  Copyright (c) 2020 Open Whisper Systems. All rights reserved.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct SessionRecordProtos_SessionStructure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionVersion: UInt32 {
    get {return _storage._sessionVersion}
    set {_uniqueStorage()._sessionVersion = newValue}
  }

  var localIdentityPublic: Data {
    get {return _storage._localIdentityPublic}
    set {_uniqueStorage()._localIdentityPublic = newValue}
  }

  var remoteIdentityPublic: Data {
    get {return _storage._remoteIdentityPublic}
    set {_uniqueStorage()._remoteIdentityPublic = newValue}
  }

  var rootKey: Data {
    get {return _storage._rootKey}
    set {_uniqueStorage()._rootKey = newValue}
  }

  var previousCounter: UInt32 {
    get {return _storage._previousCounter}
    set {_uniqueStorage()._previousCounter = newValue}
  }

  var senderChain: SessionRecordProtos_SessionStructure.Chain {
    get {return _storage._senderChain ?? SessionRecordProtos_SessionStructure.Chain()}
    set {_uniqueStorage()._senderChain = newValue}
  }
  /// Returns true if `senderChain` has been explicitly set.
  var hasSenderChain: Bool {return _storage._senderChain != nil}
  /// Clears the value of `senderChain`. Subsequent reads from it will return its default value.
  mutating func clearSenderChain() {_uniqueStorage()._senderChain = nil}

  var receiverChains: [SessionRecordProtos_SessionStructure.Chain] {
    get {return _storage._receiverChains}
    set {_uniqueStorage()._receiverChains = newValue}
  }

  var pendingPreKey: SessionRecordProtos_SessionStructure.PendingPreKey {
    get {return _storage._pendingPreKey ?? SessionRecordProtos_SessionStructure.PendingPreKey()}
    set {_uniqueStorage()._pendingPreKey = newValue}
  }
  /// Returns true if `pendingPreKey` has been explicitly set.
  var hasPendingPreKey: Bool {return _storage._pendingPreKey != nil}
  /// Clears the value of `pendingPreKey`. Subsequent reads from it will return its default value.
  mutating func clearPendingPreKey() {_uniqueStorage()._pendingPreKey = nil}

  var remoteRegistrationID: UInt32 {
    get {return _storage._remoteRegistrationID}
    set {_uniqueStorage()._remoteRegistrationID = newValue}
  }

  var localRegistrationID: UInt32 {
    get {return _storage._localRegistrationID}
    set {_uniqueStorage()._localRegistrationID = newValue}
  }

  var needsRefresh: Bool {
    get {return _storage._needsRefresh}
    set {_uniqueStorage()._needsRefresh = newValue}
  }

  var aliceBaseKey: Data {
    get {return _storage._aliceBaseKey}
    set {_uniqueStorage()._aliceBaseKey = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Chain {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var senderRatchetKey: Data = Data()

    var senderRatchetKeyPrivate: Data = Data()

    var chainKey: SessionRecordProtos_SessionStructure.Chain.ChainKey {
      get {return _chainKey ?? SessionRecordProtos_SessionStructure.Chain.ChainKey()}
      set {_chainKey = newValue}
    }
    /// Returns true if `chainKey` has been explicitly set.
    var hasChainKey: Bool {return self._chainKey != nil}
    /// Clears the value of `chainKey`. Subsequent reads from it will return its default value.
    mutating func clearChainKey() {self._chainKey = nil}

    var messageKeys: [SessionRecordProtos_SessionStructure.Chain.MessageKey] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct ChainKey {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var index: UInt32 = 0

      var key: Data = Data()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct MessageKey {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var index: UInt32 = 0

      var cipherKey: Data = Data()

      var macKey: Data = Data()

      var iv: Data = Data()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _chainKey: SessionRecordProtos_SessionStructure.Chain.ChainKey? = nil
  }

  struct PendingPreKey {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var preKeyID: UInt32 = 0

    var signedPreKeyID: Int32 = 0

    var baseKey: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SessionRecordProtos_RecordStructure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var currentSession: SessionRecordProtos_SessionStructure {
    get {return _currentSession ?? SessionRecordProtos_SessionStructure()}
    set {_currentSession = newValue}
  }
  /// Returns true if `currentSession` has been explicitly set.
  var hasCurrentSession: Bool {return self._currentSession != nil}
  /// Clears the value of `currentSession`. Subsequent reads from it will return its default value.
  mutating func clearCurrentSession() {self._currentSession = nil}

  var previousSessions: [SessionRecordProtos_SessionStructure] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _currentSession: SessionRecordProtos_SessionStructure? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "SessionRecordProtos"

extension SessionRecordProtos_SessionStructure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionStructure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_version"),
    2: .standard(proto: "local_identity_public"),
    3: .standard(proto: "remote_identity_public"),
    4: .standard(proto: "root_key"),
    5: .standard(proto: "previous_counter"),
    6: .standard(proto: "sender_chain"),
    7: .standard(proto: "receiver_chains"),
    9: .standard(proto: "pending_pre_key"),
    10: .standard(proto: "remote_registration_id"),
    11: .standard(proto: "local_registration_id"),
    12: .standard(proto: "needs_refresh"),
    13: .standard(proto: "alice_base_key"),
  ]

  fileprivate class _StorageClass {
    var _sessionVersion: UInt32 = 0
    var _localIdentityPublic: Data = Data()
    var _remoteIdentityPublic: Data = Data()
    var _rootKey: Data = Data()
    var _previousCounter: UInt32 = 0
    var _senderChain: SessionRecordProtos_SessionStructure.Chain? = nil
    var _receiverChains: [SessionRecordProtos_SessionStructure.Chain] = []
    var _pendingPreKey: SessionRecordProtos_SessionStructure.PendingPreKey? = nil
    var _remoteRegistrationID: UInt32 = 0
    var _localRegistrationID: UInt32 = 0
    var _needsRefresh: Bool = false
    var _aliceBaseKey: Data = Data()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sessionVersion = source._sessionVersion
      _localIdentityPublic = source._localIdentityPublic
      _remoteIdentityPublic = source._remoteIdentityPublic
      _rootKey = source._rootKey
      _previousCounter = source._previousCounter
      _senderChain = source._senderChain
      _receiverChains = source._receiverChains
      _pendingPreKey = source._pendingPreKey
      _remoteRegistrationID = source._remoteRegistrationID
      _localRegistrationID = source._localRegistrationID
      _needsRefresh = source._needsRefresh
      _aliceBaseKey = source._aliceBaseKey
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._sessionVersion) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._localIdentityPublic) }()
        case 3: try { try decoder.decodeSingularBytesField(value: &_storage._remoteIdentityPublic) }()
        case 4: try { try decoder.decodeSingularBytesField(value: &_storage._rootKey) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._previousCounter) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._senderChain) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._receiverChains) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._pendingPreKey) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._remoteRegistrationID) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._localRegistrationID) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._needsRefresh) }()
        case 13: try { try decoder.decodeSingularBytesField(value: &_storage._aliceBaseKey) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._sessionVersion != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._sessionVersion, fieldNumber: 1)
      }
      if !_storage._localIdentityPublic.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._localIdentityPublic, fieldNumber: 2)
      }
      if !_storage._remoteIdentityPublic.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._remoteIdentityPublic, fieldNumber: 3)
      }
      if !_storage._rootKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._rootKey, fieldNumber: 4)
      }
      if _storage._previousCounter != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._previousCounter, fieldNumber: 5)
      }
      if let v = _storage._senderChain {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._receiverChains.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._receiverChains, fieldNumber: 7)
      }
      if let v = _storage._pendingPreKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if _storage._remoteRegistrationID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._remoteRegistrationID, fieldNumber: 10)
      }
      if _storage._localRegistrationID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._localRegistrationID, fieldNumber: 11)
      }
      if _storage._needsRefresh != false {
        try visitor.visitSingularBoolField(value: _storage._needsRefresh, fieldNumber: 12)
      }
      if !_storage._aliceBaseKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._aliceBaseKey, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionRecordProtos_SessionStructure, rhs: SessionRecordProtos_SessionStructure) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sessionVersion != rhs_storage._sessionVersion {return false}
        if _storage._localIdentityPublic != rhs_storage._localIdentityPublic {return false}
        if _storage._remoteIdentityPublic != rhs_storage._remoteIdentityPublic {return false}
        if _storage._rootKey != rhs_storage._rootKey {return false}
        if _storage._previousCounter != rhs_storage._previousCounter {return false}
        if _storage._senderChain != rhs_storage._senderChain {return false}
        if _storage._receiverChains != rhs_storage._receiverChains {return false}
        if _storage._pendingPreKey != rhs_storage._pendingPreKey {return false}
        if _storage._remoteRegistrationID != rhs_storage._remoteRegistrationID {return false}
        if _storage._localRegistrationID != rhs_storage._localRegistrationID {return false}
        if _storage._needsRefresh != rhs_storage._needsRefresh {return false}
        if _storage._aliceBaseKey != rhs_storage._aliceBaseKey {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionRecordProtos_SessionStructure.Chain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SessionRecordProtos_SessionStructure.protoMessageName + ".Chain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sender_ratchet_key"),
    2: .standard(proto: "sender_ratchet_key_private"),
    3: .standard(proto: "chain_key"),
    4: .standard(proto: "message_keys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.senderRatchetKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.senderRatchetKeyPrivate) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._chainKey) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.messageKeys) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.senderRatchetKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.senderRatchetKey, fieldNumber: 1)
    }
    if !self.senderRatchetKeyPrivate.isEmpty {
      try visitor.visitSingularBytesField(value: self.senderRatchetKeyPrivate, fieldNumber: 2)
    }
    if let v = self._chainKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.messageKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messageKeys, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionRecordProtos_SessionStructure.Chain, rhs: SessionRecordProtos_SessionStructure.Chain) -> Bool {
    if lhs.senderRatchetKey != rhs.senderRatchetKey {return false}
    if lhs.senderRatchetKeyPrivate != rhs.senderRatchetKeyPrivate {return false}
    if lhs._chainKey != rhs._chainKey {return false}
    if lhs.messageKeys != rhs.messageKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionRecordProtos_SessionStructure.Chain.ChainKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SessionRecordProtos_SessionStructure.Chain.protoMessageName + ".ChainKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionRecordProtos_SessionStructure.Chain.ChainKey, rhs: SessionRecordProtos_SessionStructure.Chain.ChainKey) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionRecordProtos_SessionStructure.Chain.MessageKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SessionRecordProtos_SessionStructure.Chain.protoMessageName + ".MessageKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .standard(proto: "cipher_key"),
    3: .standard(proto: "mac_key"),
    4: .same(proto: "iv"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.cipherKey) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.macKey) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.iv) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    if !self.cipherKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.cipherKey, fieldNumber: 2)
    }
    if !self.macKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.macKey, fieldNumber: 3)
    }
    if !self.iv.isEmpty {
      try visitor.visitSingularBytesField(value: self.iv, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionRecordProtos_SessionStructure.Chain.MessageKey, rhs: SessionRecordProtos_SessionStructure.Chain.MessageKey) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.cipherKey != rhs.cipherKey {return false}
    if lhs.macKey != rhs.macKey {return false}
    if lhs.iv != rhs.iv {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionRecordProtos_SessionStructure.PendingPreKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SessionRecordProtos_SessionStructure.protoMessageName + ".PendingPreKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pre_key_id"),
    3: .standard(proto: "signed_pre_key_id"),
    2: .standard(proto: "base_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.preKeyID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.baseKey) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.signedPreKeyID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.preKeyID != 0 {
      try visitor.visitSingularUInt32Field(value: self.preKeyID, fieldNumber: 1)
    }
    if !self.baseKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.baseKey, fieldNumber: 2)
    }
    if self.signedPreKeyID != 0 {
      try visitor.visitSingularInt32Field(value: self.signedPreKeyID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionRecordProtos_SessionStructure.PendingPreKey, rhs: SessionRecordProtos_SessionStructure.PendingPreKey) -> Bool {
    if lhs.preKeyID != rhs.preKeyID {return false}
    if lhs.signedPreKeyID != rhs.signedPreKeyID {return false}
    if lhs.baseKey != rhs.baseKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionRecordProtos_RecordStructure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordStructure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "current_session"),
    2: .standard(proto: "previous_sessions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._currentSession) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.previousSessions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._currentSession {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.previousSessions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.previousSessions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionRecordProtos_RecordStructure, rhs: SessionRecordProtos_RecordStructure) -> Bool {
    if lhs._currentSession != rhs._currentSession {return false}
    if lhs.previousSessions != rhs.previousSessions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
