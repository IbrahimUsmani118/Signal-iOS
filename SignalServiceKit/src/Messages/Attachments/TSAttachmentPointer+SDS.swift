//
//  Copyright (c) 2019 Open Whisper Systems. All rights reserved.
//

import Foundation
import GRDBCipher
import SignalCoreKit

// NOTE: This file is generated by /Scripts/sds_codegen/sds_generate.py.
// Do not manually edit it, instead run `sds_codegen.sh`.

// MARK: - SDSSerializer

// The SDSSerializer protocol specifies how to insert and update the
// row that corresponds to this model.
class TSAttachmentPointerSerializer: SDSSerializer {

    private let model: TSAttachmentPointer
    public required init(model: TSAttachmentPointer) {
        self.model = model
    }

    public func serializableColumnTableMetadata() -> SDSTableMetadata {
        return TSAttachmentSerializer.table
    }

    public func insertColumnNames() -> [String] {
        // When we insert a new row, we include the following columns:
        //
        // * "record type"
        // * "unique id"
        // * ...all columns that we set when updating.
        return [
            TSAttachmentSerializer.recordTypeColumn.columnName,
            uniqueIdColumnName()
            ] + updateColumnNames()

    }

    public func insertColumnValues() -> [DatabaseValueConvertible] {
        let result: [DatabaseValueConvertible] = [
            SDSRecordType.attachmentPointer.rawValue
            ] + [uniqueIdColumnValue()] + updateColumnValues()
        if OWSIsDebugBuild() {
            if result.count != insertColumnNames().count {
                owsFailDebug("Update mismatch: \(result.count) != \(insertColumnNames().count)")
            }
        }
        return result
    }

    public func updateColumnNames() -> [String] {
        return [
            TSAttachmentSerializer.albumMessageIdColumn,
            TSAttachmentSerializer.attachmentSchemaVersionColumn,
            TSAttachmentSerializer.attachmentTypeColumn,
            TSAttachmentSerializer.byteCountColumn,
            TSAttachmentSerializer.captionColumn,
            TSAttachmentSerializer.contentTypeColumn,
            TSAttachmentSerializer.encryptionKeyColumn,
            TSAttachmentSerializer.isDownloadedColumn,
            TSAttachmentSerializer.serverIdColumn,
            TSAttachmentSerializer.sourceFilenameColumn,
            TSAttachmentSerializer.digestColumn,
            TSAttachmentSerializer.lazyRestoreFragmentIdColumn,
            TSAttachmentSerializer.mediaSizeColumn,
            TSAttachmentSerializer.mostRecentFailureLocalizedTextColumn,
            TSAttachmentSerializer.pointerTypeColumn,
            TSAttachmentSerializer.stateColumn
            ].map { $0.columnName }
    }

    public func updateColumnValues() -> [DatabaseValueConvertible] {
        let result: [DatabaseValueConvertible] = [
            self.model.albumMessageId ?? DatabaseValue.null,
            self.model.attachmentSchemaVersion,
            self.model.attachmentType.rawValue,
            self.model.byteCount,
            self.model.caption ?? DatabaseValue.null,
            self.model.contentType,
            self.model.encryptionKey ?? DatabaseValue.null,
            self.model.isDownloaded,
            self.model.serverId,
            self.model.sourceFilename ?? DatabaseValue.null,
            self.model.digest ?? DatabaseValue.null,
            self.model.lazyRestoreFragmentId ?? DatabaseValue.null,
            SDSDeserializer.archive(self.model.mediaSize) ?? DatabaseValue.null,
            self.model.mostRecentFailureLocalizedText ?? DatabaseValue.null,
            self.model.pointerType.rawValue,
            self.model.state.rawValue

        ]
        if OWSIsDebugBuild() {
            if result.count != updateColumnNames().count {
                owsFailDebug("Update mismatch: \(result.count) != \(updateColumnNames().count)")
            }
        }
        return result
    }

    public func uniqueIdColumnName() -> String {
        return TSAttachmentSerializer.uniqueIdColumn.columnName
    }

    // TODO: uniqueId is currently an optional on our models.
    //       We should probably make the return type here String?
    public func uniqueIdColumnValue() -> DatabaseValueConvertible {
        // FIXME remove force unwrap
        return model.uniqueId!
    }
}
