//
//  Copyright (c) 2019 Open Whisper Systems. All rights reserved.
//

import Foundation
import GRDBCipher
import SignalCoreKit

// NOTE: This file is generated by /Scripts/sds_codegen/sds_generate.py.
// Do not manually edit it, instead run `sds_codegen.sh`.

// MARK: - SDSSerializer

// The SDSSerializer protocol specifies how to insert and update the
// row that corresponds to this model.
class TSAttachmentStreamSerializer: SDSSerializer {

    private let model: TSAttachmentStream
    public required init(model: TSAttachmentStream) {
        self.model = model
    }

    // MARK: - Record

    func toRecord() throws -> AttachmentRecord {
        let id: Int64? = nil

        let recordType: SDSRecordType = .attachmentStream
        guard let uniqueId: String = model.uniqueId else {
            owsFailDebug("Missing uniqueId.")
            throw SDSError.missingRequiredField
        }

        // Base class properties
        let albumMessageId: String? = model.albumMessageId
        let attachmentSchemaVersion: UInt = model.attachmentSchemaVersion
        let attachmentType: TSAttachmentType = model.attachmentType
        let byteCount: UInt32 = model.byteCount
        let caption: String? = model.caption
        let contentType: String = model.contentType
        let encryptionKey: Data? = model.encryptionKey
        let isDownloaded: Bool = model.isDownloaded
        let serverId: UInt64 = model.serverId
        let sourceFilename: String? = model.sourceFilename

        // Subclass properties
        let cachedAudioDurationSeconds: Double? = archiveOptionalNSNumber(model.cachedAudioDurationSeconds, conversion: { $0.doubleValue })
        let cachedImageHeight: Double? = archiveOptionalNSNumber(model.cachedImageHeight, conversion: { $0.doubleValue })
        let cachedImageWidth: Double? = archiveOptionalNSNumber(model.cachedImageWidth, conversion: { $0.doubleValue })
        let creationTimestamp: Date? = model.creationTimestamp
        let digest: Data? = model.digest
        let isUploaded: Bool? = model.isUploaded
        let isValidImageCached: Bool? = archiveOptionalNSNumber(model.isValidImageCached, conversion: { $0.boolValue })
        let isValidVideoCached: Bool? = archiveOptionalNSNumber(model.isValidVideoCached, conversion: { $0.boolValue })
        let lazyRestoreFragmentId: String? = nil
        let localRelativeFilePath: String? = model.localRelativeFilePath
        let mediaSize: CGSize? = nil
        let mostRecentFailureLocalizedText: String? = nil
        let pointerType: TSAttachmentPointerType? = nil
        let shouldAlwaysPad: Bool? = model.shouldAlwaysPad
        let state: TSAttachmentPointerState? = nil

        return AttachmentRecord(id: id, recordType: recordType, uniqueId: uniqueId, albumMessageId: albumMessageId, attachmentSchemaVersion: attachmentSchemaVersion, attachmentType: attachmentType, byteCount: byteCount, caption: caption, contentType: contentType, encryptionKey: encryptionKey, isDownloaded: isDownloaded, serverId: serverId, sourceFilename: sourceFilename, cachedAudioDurationSeconds: cachedAudioDurationSeconds, cachedImageHeight: cachedImageHeight, cachedImageWidth: cachedImageWidth, creationTimestamp: creationTimestamp, digest: digest, isUploaded: isUploaded, isValidImageCached: isValidImageCached, isValidVideoCached: isValidVideoCached, lazyRestoreFragmentId: lazyRestoreFragmentId, localRelativeFilePath: localRelativeFilePath, mediaSize: mediaSize, mostRecentFailureLocalizedText: mostRecentFailureLocalizedText, pointerType: pointerType, shouldAlwaysPad: shouldAlwaysPad, state: state)
    }

    public func serializableColumnTableMetadata() -> SDSTableMetadata {
        return TSAttachmentSerializer.table
    }

    public func updateColumnNames() -> [String] {
        return [
            TSAttachmentSerializer.idColumn,
            TSAttachmentSerializer.albumMessageIdColumn,
            TSAttachmentSerializer.attachmentSchemaVersionColumn,
            TSAttachmentSerializer.attachmentTypeColumn,
            TSAttachmentSerializer.byteCountColumn,
            TSAttachmentSerializer.captionColumn,
            TSAttachmentSerializer.contentTypeColumn,
            TSAttachmentSerializer.encryptionKeyColumn,
            TSAttachmentSerializer.isDownloadedColumn,
            TSAttachmentSerializer.serverIdColumn,
            TSAttachmentSerializer.sourceFilenameColumn,
            TSAttachmentSerializer.cachedAudioDurationSecondsColumn,
            TSAttachmentSerializer.cachedImageHeightColumn,
            TSAttachmentSerializer.cachedImageWidthColumn,
            TSAttachmentSerializer.creationTimestampColumn,
            TSAttachmentSerializer.digestColumn,
            TSAttachmentSerializer.isUploadedColumn,
            TSAttachmentSerializer.isValidImageCachedColumn,
            TSAttachmentSerializer.isValidVideoCachedColumn,
            TSAttachmentSerializer.localRelativeFilePathColumn,
            TSAttachmentSerializer.shouldAlwaysPadColumn
            ].map { $0.columnName }
    }

    public func uniqueIdColumnName() -> String {
        return TSAttachmentSerializer.uniqueIdColumn.columnName
    }

    // TODO: uniqueId is currently an optional on our models.
    //       We should probably make the return type here String?
    public func uniqueIdColumnValue() -> DatabaseValueConvertible {
        // FIXME remove force unwrap
        return model.uniqueId!
    }
}
