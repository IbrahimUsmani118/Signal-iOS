//
//  Copyright (c) 2019 Open Whisper Systems. All rights reserved.
//

import Foundation
import GRDBCipher
import SignalCoreKit

// NOTE: This file is generated by /Scripts/sds_codegen/sds_generate.py.
// Do not manually edit it, instead run `sds_codegen.sh`.

// MARK: - Record

public struct InteractionRecord: Codable, FetchableRecord, PersistableRecord, TableRecord {
    public static let databaseTableName: String = TSInteractionSerializer.table.tableName

    public let id: UInt64

    // This defines all of the columns used in the table
    // where this model (and any subclasses) are persisted.
    public let recordType: SDSRecordType
    public let uniqueId: String

    // Base class properties
    public let receivedAtTimestamp: UInt64
    public let timestamp: UInt64
    public let threadUniqueId: String

    // Subclass properties
    public let attachmentFilenameMap: Data?
    public let attachmentIds: Data?
    public let authorId: String?
    public let beforeInteractionId: String?
    public let body: String?
    public let callSchemaVersion: UInt?
    public let callType: RPRecentCallType?
    public let configurationDurationSeconds: UInt32?
    public let configurationIsEnabled: Bool?
    public let contactId: String?
    public let contactShare: Data?
    public let createdByRemoteName: String?
    public let createdInExistingGroup: Bool?
    public let customMessage: String?
    public let envelopeData: Data?
    public let errorMessageSchemaVersion: UInt?
    public let errorType: TSErrorMessageType?
    public let expireStartedAt: UInt64?
    public let expiresAt: UInt64?
    public let expiresInSeconds: UInt32?
    public let groupMetaMessage: TSGroupMetaMessage?
    public let hasAddToContactsOffer: Bool?
    public let hasAddToProfileWhitelistOffer: Bool?
    public let hasBlockOffer: Bool?
    public let hasLegacyMessageState: Bool?
    public let hasSyncedTranscript: Bool?
    public let infoMessageSchemaVersion: UInt?
    public let isFromLinkedDevice: Bool?
    public let isLocalChange: Bool?
    public let isVoiceMessage: Bool?
    public let legacyMessageState: TSOutgoingMessageState?
    public let legacyWasDelivered: Bool?
    public let linkPreview: Data?
    public let messageId: String?
    public let messageSticker: Data?
    public let messageType: TSInfoMessageType?
    public let mostRecentFailureText: String?
    public let preKeyBundle: Data?
    public let quotedMessage: Data?
    public let read: Bool?
    public let recipientId: String?
    public let recipientStateMap: Data?
    public let schemaVersion: UInt?
    public let serverTimestamp: UInt64?
    public let sourceDeviceId: UInt32?
    public let unregisteredRecipientId: String?
    public let verificationState: OWSVerificationState?
    public let wasReceivedByUD: Bool?

    public enum CodingKeys: String, CodingKey, ColumnExpression, CaseIterable {
        case id
        case recordType
        case uniqueId
        case receivedAtTimestamp
        case timestamp
        case threadUniqueId = "uniqueThreadId"
        case attachmentFilenameMap
        case attachmentIds
        case authorId
        case beforeInteractionId
        case body
        case callSchemaVersion
        case callType
        case configurationDurationSeconds
        case configurationIsEnabled
        case contactId
        case contactShare
        case createdByRemoteName
        case createdInExistingGroup
        case customMessage
        case envelopeData
        case errorMessageSchemaVersion
        case errorType
        case expireStartedAt
        case expiresAt
        case expiresInSeconds
        case groupMetaMessage
        case hasAddToContactsOffer
        case hasAddToProfileWhitelistOffer
        case hasBlockOffer
        case hasLegacyMessageState
        case hasSyncedTranscript
        case infoMessageSchemaVersion
        case isFromLinkedDevice
        case isLocalChange
        case isVoiceMessage
        case legacyMessageState
        case legacyWasDelivered
        case linkPreview
        case messageId
        case messageSticker
        case messageType
        case mostRecentFailureText
        case preKeyBundle
        case quotedMessage
        case read
        case recipientId
        case recipientStateMap
        case schemaVersion
        case serverTimestamp
        case sourceDeviceId
        case unregisteredRecipientId
        case verificationState
        case wasReceivedByUD
    }

    public static func columnName(_ column: InteractionRecord.CodingKeys) -> String {
        return column.rawValue
    }

}

// MARK: - StringInterpolation

public extension String.StringInterpolation {
    mutating func appendInterpolation(columnForInteraction column: InteractionRecord.CodingKeys) {
        appendLiteral(InteractionRecord.columnName(column))
    }
}

// MARK: - Deserialization

// TODO: Remove the other Deserialization extension.
// TODO: SDSDeserializer.
// TODO: Rework metadata to not include, for example, columns, column indices.
extension TSInteraction {
    // This method defines how to deserialize a model, given a
    // database row.  The recordType column is used to determine
    // the corresponding model class.
    class func fromRecord(_ record: InteractionRecord) throws -> TSInteraction {

        switch record.recordType {
        case .addToContactsOfferMessage:

            let uniqueId: String = record.uniqueId
            let sortId: UInt64 = record.id
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = SDSDeserialization.optionalString(record.body, name: "body")
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.numeric(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.numeric(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.numeric(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.numeric(record.schemaVersion, name: "schemaVersion")
            let customMessage: String? = SDSDeserialization.optionalString(record.customMessage, name: "customMessage")
            let infoMessageSchemaVersion: UInt = try SDSDeserialization.numeric(record.infoMessageSchemaVersion, name: "infoMessageSchemaVersion")
            guard let messageType: TSInfoMessageType = record.messageType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.numeric(record.read, name: "read")
            let unregisteredRecipientId: String? = SDSDeserialization.optionalString(record.unregisteredRecipientId, name: "unregisteredRecipientId")
            let contactId: String = try SDSDeserialization.string(record.contactId, name: "contactId")

            return OWSAddToContactsOfferMessage(uniqueId: uniqueId,
                                                receivedAtTimestamp: receivedAtTimestamp,
                                                sortId: sortId,
                                                timestamp: timestamp,
                                                uniqueThreadId: uniqueThreadId,
                                                attachmentIds: attachmentIds,
                                                body: body,
                                                contactShare: contactShare,
                                                expireStartedAt: expireStartedAt,
                                                expiresAt: expiresAt,
                                                expiresInSeconds: expiresInSeconds,
                                                linkPreview: linkPreview,
                                                messageSticker: messageSticker,
                                                quotedMessage: quotedMessage,
                                                schemaVersion: schemaVersion,
                                                customMessage: customMessage,
                                                infoMessageSchemaVersion: infoMessageSchemaVersion,
                                                messageType: messageType,
                                                read: read,
                                                unregisteredRecipientId: unregisteredRecipientId,
                                                contactId: contactId)

        case .addToProfileWhitelistOfferMessage:

            let uniqueId: String = record.uniqueId
            let sortId: UInt64 = record.id
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = SDSDeserialization.optionalString(record.body, name: "body")
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.numeric(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.numeric(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.numeric(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.numeric(record.schemaVersion, name: "schemaVersion")
            let customMessage: String? = SDSDeserialization.optionalString(record.customMessage, name: "customMessage")
            let infoMessageSchemaVersion: UInt = try SDSDeserialization.numeric(record.infoMessageSchemaVersion, name: "infoMessageSchemaVersion")
            guard let messageType: TSInfoMessageType = record.messageType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.numeric(record.read, name: "read")
            let unregisteredRecipientId: String? = SDSDeserialization.optionalString(record.unregisteredRecipientId, name: "unregisteredRecipientId")
            let contactId: String = try SDSDeserialization.string(record.contactId, name: "contactId")

            return OWSAddToProfileWhitelistOfferMessage(uniqueId: uniqueId,
                                                        receivedAtTimestamp: receivedAtTimestamp,
                                                        sortId: sortId,
                                                        timestamp: timestamp,
                                                        uniqueThreadId: uniqueThreadId,
                                                        attachmentIds: attachmentIds,
                                                        body: body,
                                                        contactShare: contactShare,
                                                        expireStartedAt: expireStartedAt,
                                                        expiresAt: expiresAt,
                                                        expiresInSeconds: expiresInSeconds,
                                                        linkPreview: linkPreview,
                                                        messageSticker: messageSticker,
                                                        quotedMessage: quotedMessage,
                                                        schemaVersion: schemaVersion,
                                                        customMessage: customMessage,
                                                        infoMessageSchemaVersion: infoMessageSchemaVersion,
                                                        messageType: messageType,
                                                        read: read,
                                                        unregisteredRecipientId: unregisteredRecipientId,
                                                        contactId: contactId)

        case .contactOffersInteraction:

            let uniqueId: String = record.uniqueId
            let sortId: UInt64 = record.id
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let beforeInteractionId: String = try SDSDeserialization.string(record.beforeInteractionId, name: "beforeInteractionId")
            let hasAddToContactsOffer: Bool = try SDSDeserialization.numeric(record.hasAddToContactsOffer, name: "hasAddToContactsOffer")
            let hasAddToProfileWhitelistOffer: Bool = try SDSDeserialization.numeric(record.hasAddToProfileWhitelistOffer, name: "hasAddToProfileWhitelistOffer")
            let hasBlockOffer: Bool = try SDSDeserialization.numeric(record.hasBlockOffer, name: "hasBlockOffer")
            let recipientId: String = try SDSDeserialization.string(record.recipientId, name: "recipientId")

            return OWSContactOffersInteraction(uniqueId: uniqueId,
                                               receivedAtTimestamp: receivedAtTimestamp,
                                               sortId: sortId,
                                               timestamp: timestamp,
                                               uniqueThreadId: uniqueThreadId,
                                               beforeInteractionId: beforeInteractionId,
                                               hasAddToContactsOffer: hasAddToContactsOffer,
                                               hasAddToProfileWhitelistOffer: hasAddToProfileWhitelistOffer,
                                               hasBlockOffer: hasBlockOffer,
                                               recipientId: recipientId)

        case .disappearingConfigurationUpdateInfoMessage:

            let uniqueId: String = record.uniqueId
            let sortId: UInt64 = record.id
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = SDSDeserialization.optionalString(record.body, name: "body")
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.numeric(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.numeric(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.numeric(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.numeric(record.schemaVersion, name: "schemaVersion")
            let customMessage: String? = SDSDeserialization.optionalString(record.customMessage, name: "customMessage")
            let infoMessageSchemaVersion: UInt = try SDSDeserialization.numeric(record.infoMessageSchemaVersion, name: "infoMessageSchemaVersion")
            guard let messageType: TSInfoMessageType = record.messageType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.numeric(record.read, name: "read")
            let unregisteredRecipientId: String? = SDSDeserialization.optionalString(record.unregisteredRecipientId, name: "unregisteredRecipientId")
            let configurationDurationSeconds: UInt32 = try SDSDeserialization.numeric(record.configurationDurationSeconds, name: "configurationDurationSeconds")
            let configurationIsEnabled: Bool = try SDSDeserialization.numeric(record.configurationIsEnabled, name: "configurationIsEnabled")
            let createdByRemoteName: String? = SDSDeserialization.optionalString(record.createdByRemoteName, name: "createdByRemoteName")
            let createdInExistingGroup: Bool = try SDSDeserialization.numeric(record.createdInExistingGroup, name: "createdInExistingGroup")

            return OWSDisappearingConfigurationUpdateInfoMessage(uniqueId: uniqueId,
                                                                 receivedAtTimestamp: receivedAtTimestamp,
                                                                 sortId: sortId,
                                                                 timestamp: timestamp,
                                                                 uniqueThreadId: uniqueThreadId,
                                                                 attachmentIds: attachmentIds,
                                                                 body: body,
                                                                 contactShare: contactShare,
                                                                 expireStartedAt: expireStartedAt,
                                                                 expiresAt: expiresAt,
                                                                 expiresInSeconds: expiresInSeconds,
                                                                 linkPreview: linkPreview,
                                                                 messageSticker: messageSticker,
                                                                 quotedMessage: quotedMessage,
                                                                 schemaVersion: schemaVersion,
                                                                 customMessage: customMessage,
                                                                 infoMessageSchemaVersion: infoMessageSchemaVersion,
                                                                 messageType: messageType,
                                                                 read: read,
                                                                 unregisteredRecipientId: unregisteredRecipientId,
                                                                 configurationDurationSeconds: configurationDurationSeconds,
                                                                 configurationIsEnabled: configurationIsEnabled,
                                                                 createdByRemoteName: createdByRemoteName,
                                                                 createdInExistingGroup: createdInExistingGroup)

        case .unknownContactBlockOfferMessage:

            let uniqueId: String = record.uniqueId
            let sortId: UInt64 = record.id
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = SDSDeserialization.optionalString(record.body, name: "body")
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.numeric(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.numeric(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.numeric(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.numeric(record.schemaVersion, name: "schemaVersion")
            let errorMessageSchemaVersion: UInt = try SDSDeserialization.numeric(record.errorMessageSchemaVersion, name: "errorMessageSchemaVersion")
            guard let errorType: TSErrorMessageType = record.errorType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.numeric(record.read, name: "read")
            let recipientId: String? = SDSDeserialization.optionalString(record.recipientId, name: "recipientId")
            let contactId: String = try SDSDeserialization.string(record.contactId, name: "contactId")

            return OWSUnknownContactBlockOfferMessage(uniqueId: uniqueId,
                                                      receivedAtTimestamp: receivedAtTimestamp,
                                                      sortId: sortId,
                                                      timestamp: timestamp,
                                                      uniqueThreadId: uniqueThreadId,
                                                      attachmentIds: attachmentIds,
                                                      body: body,
                                                      contactShare: contactShare,
                                                      expireStartedAt: expireStartedAt,
                                                      expiresAt: expiresAt,
                                                      expiresInSeconds: expiresInSeconds,
                                                      linkPreview: linkPreview,
                                                      messageSticker: messageSticker,
                                                      quotedMessage: quotedMessage,
                                                      schemaVersion: schemaVersion,
                                                      errorMessageSchemaVersion: errorMessageSchemaVersion,
                                                      errorType: errorType,
                                                      read: read,
                                                      recipientId: recipientId,
                                                      contactId: contactId)

        case .verificationStateChangeMessage:

            let uniqueId: String = record.uniqueId
            let sortId: UInt64 = record.id
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = SDSDeserialization.optionalString(record.body, name: "body")
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.numeric(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.numeric(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.numeric(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.numeric(record.schemaVersion, name: "schemaVersion")
            let customMessage: String? = SDSDeserialization.optionalString(record.customMessage, name: "customMessage")
            let infoMessageSchemaVersion: UInt = try SDSDeserialization.numeric(record.infoMessageSchemaVersion, name: "infoMessageSchemaVersion")
            guard let messageType: TSInfoMessageType = record.messageType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.numeric(record.read, name: "read")
            let unregisteredRecipientId: String? = SDSDeserialization.optionalString(record.unregisteredRecipientId, name: "unregisteredRecipientId")
            let isLocalChange: Bool = try SDSDeserialization.numeric(record.isLocalChange, name: "isLocalChange")
            let recipientId: String = try SDSDeserialization.string(record.recipientId, name: "recipientId")
            guard let verificationState: OWSVerificationState = record.verificationState else {
               throw SDSError.missingRequiredField
            }

            return OWSVerificationStateChangeMessage(uniqueId: uniqueId,
                                                     receivedAtTimestamp: receivedAtTimestamp,
                                                     sortId: sortId,
                                                     timestamp: timestamp,
                                                     uniqueThreadId: uniqueThreadId,
                                                     attachmentIds: attachmentIds,
                                                     body: body,
                                                     contactShare: contactShare,
                                                     expireStartedAt: expireStartedAt,
                                                     expiresAt: expiresAt,
                                                     expiresInSeconds: expiresInSeconds,
                                                     linkPreview: linkPreview,
                                                     messageSticker: messageSticker,
                                                     quotedMessage: quotedMessage,
                                                     schemaVersion: schemaVersion,
                                                     customMessage: customMessage,
                                                     infoMessageSchemaVersion: infoMessageSchemaVersion,
                                                     messageType: messageType,
                                                     read: read,
                                                     unregisteredRecipientId: unregisteredRecipientId,
                                                     isLocalChange: isLocalChange,
                                                     recipientId: recipientId,
                                                     verificationState: verificationState)

        case .call:

            let uniqueId: String = record.uniqueId
            let sortId: UInt64 = record.id
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let callSchemaVersion: UInt = try SDSDeserialization.numeric(record.callSchemaVersion, name: "callSchemaVersion")
            guard let callType: RPRecentCallType = record.callType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.numeric(record.read, name: "read")

            return TSCall(uniqueId: uniqueId,
                          receivedAtTimestamp: receivedAtTimestamp,
                          sortId: sortId,
                          timestamp: timestamp,
                          uniqueThreadId: uniqueThreadId,
                          callSchemaVersion: callSchemaVersion,
                          callType: callType,
                          read: read)

        case .errorMessage:

            let uniqueId: String = record.uniqueId
            let sortId: UInt64 = record.id
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = SDSDeserialization.optionalString(record.body, name: "body")
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.numeric(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.numeric(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.numeric(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.numeric(record.schemaVersion, name: "schemaVersion")
            let errorMessageSchemaVersion: UInt = try SDSDeserialization.numeric(record.errorMessageSchemaVersion, name: "errorMessageSchemaVersion")
            guard let errorType: TSErrorMessageType = record.errorType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.numeric(record.read, name: "read")
            let recipientId: String? = SDSDeserialization.optionalString(record.recipientId, name: "recipientId")

            return TSErrorMessage(uniqueId: uniqueId,
                                  receivedAtTimestamp: receivedAtTimestamp,
                                  sortId: sortId,
                                  timestamp: timestamp,
                                  uniqueThreadId: uniqueThreadId,
                                  attachmentIds: attachmentIds,
                                  body: body,
                                  contactShare: contactShare,
                                  expireStartedAt: expireStartedAt,
                                  expiresAt: expiresAt,
                                  expiresInSeconds: expiresInSeconds,
                                  linkPreview: linkPreview,
                                  messageSticker: messageSticker,
                                  quotedMessage: quotedMessage,
                                  schemaVersion: schemaVersion,
                                  errorMessageSchemaVersion: errorMessageSchemaVersion,
                                  errorType: errorType,
                                  read: read,
                                  recipientId: recipientId)

        case .incomingMessage:

            let uniqueId: String = record.uniqueId
            let sortId: UInt64 = record.id
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = SDSDeserialization.optionalString(record.body, name: "body")
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.numeric(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.numeric(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.numeric(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.numeric(record.schemaVersion, name: "schemaVersion")
            let authorId: String = try SDSDeserialization.string(record.authorId, name: "authorId")
            let read: Bool = try SDSDeserialization.numeric(record.read, name: "read")
            let serverTimestamp: NSNumber? = SDSDeserialization.optionalNumericAsNSNumber(record.serverTimestamp, name: "serverTimestamp", conversion: { NSNumber(value: $0) })
            let sourceDeviceId: UInt32 = try SDSDeserialization.numeric(record.sourceDeviceId, name: "sourceDeviceId")
            let wasReceivedByUD: Bool = try SDSDeserialization.numeric(record.wasReceivedByUD, name: "wasReceivedByUD")

            return TSIncomingMessage(uniqueId: uniqueId,
                                     receivedAtTimestamp: receivedAtTimestamp,
                                     sortId: sortId,
                                     timestamp: timestamp,
                                     uniqueThreadId: uniqueThreadId,
                                     attachmentIds: attachmentIds,
                                     body: body,
                                     contactShare: contactShare,
                                     expireStartedAt: expireStartedAt,
                                     expiresAt: expiresAt,
                                     expiresInSeconds: expiresInSeconds,
                                     linkPreview: linkPreview,
                                     messageSticker: messageSticker,
                                     quotedMessage: quotedMessage,
                                     schemaVersion: schemaVersion,
                                     authorId: authorId,
                                     read: read,
                                     serverTimestamp: serverTimestamp,
                                     sourceDeviceId: sourceDeviceId,
                                     wasReceivedByUD: wasReceivedByUD)

        case .infoMessage:

            let uniqueId: String = record.uniqueId
            let sortId: UInt64 = record.id
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = SDSDeserialization.optionalString(record.body, name: "body")
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.numeric(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.numeric(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.numeric(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.numeric(record.schemaVersion, name: "schemaVersion")
            let customMessage: String? = SDSDeserialization.optionalString(record.customMessage, name: "customMessage")
            let infoMessageSchemaVersion: UInt = try SDSDeserialization.numeric(record.infoMessageSchemaVersion, name: "infoMessageSchemaVersion")
            guard let messageType: TSInfoMessageType = record.messageType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.numeric(record.read, name: "read")
            let unregisteredRecipientId: String? = SDSDeserialization.optionalString(record.unregisteredRecipientId, name: "unregisteredRecipientId")

            return TSInfoMessage(uniqueId: uniqueId,
                                 receivedAtTimestamp: receivedAtTimestamp,
                                 sortId: sortId,
                                 timestamp: timestamp,
                                 uniqueThreadId: uniqueThreadId,
                                 attachmentIds: attachmentIds,
                                 body: body,
                                 contactShare: contactShare,
                                 expireStartedAt: expireStartedAt,
                                 expiresAt: expiresAt,
                                 expiresInSeconds: expiresInSeconds,
                                 linkPreview: linkPreview,
                                 messageSticker: messageSticker,
                                 quotedMessage: quotedMessage,
                                 schemaVersion: schemaVersion,
                                 customMessage: customMessage,
                                 infoMessageSchemaVersion: infoMessageSchemaVersion,
                                 messageType: messageType,
                                 read: read,
                                 unregisteredRecipientId: unregisteredRecipientId)

        case .interaction:

            let uniqueId: String = record.uniqueId
            let sortId: UInt64 = record.id
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId

            return TSInteraction(uniqueId: uniqueId,
                                 receivedAtTimestamp: receivedAtTimestamp,
                                 sortId: sortId,
                                 timestamp: timestamp,
                                 uniqueThreadId: uniqueThreadId)

        case .invalidIdentityKeyErrorMessage:

            let uniqueId: String = record.uniqueId
            let sortId: UInt64 = record.id
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = SDSDeserialization.optionalString(record.body, name: "body")
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.numeric(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.numeric(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.numeric(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.numeric(record.schemaVersion, name: "schemaVersion")
            let errorMessageSchemaVersion: UInt = try SDSDeserialization.numeric(record.errorMessageSchemaVersion, name: "errorMessageSchemaVersion")
            guard let errorType: TSErrorMessageType = record.errorType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.numeric(record.read, name: "read")
            let recipientId: String? = SDSDeserialization.optionalString(record.recipientId, name: "recipientId")

            return TSInvalidIdentityKeyErrorMessage(uniqueId: uniqueId,
                                                    receivedAtTimestamp: receivedAtTimestamp,
                                                    sortId: sortId,
                                                    timestamp: timestamp,
                                                    uniqueThreadId: uniqueThreadId,
                                                    attachmentIds: attachmentIds,
                                                    body: body,
                                                    contactShare: contactShare,
                                                    expireStartedAt: expireStartedAt,
                                                    expiresAt: expiresAt,
                                                    expiresInSeconds: expiresInSeconds,
                                                    linkPreview: linkPreview,
                                                    messageSticker: messageSticker,
                                                    quotedMessage: quotedMessage,
                                                    schemaVersion: schemaVersion,
                                                    errorMessageSchemaVersion: errorMessageSchemaVersion,
                                                    errorType: errorType,
                                                    read: read,
                                                    recipientId: recipientId)

        case .invalidIdentityKeyReceivingErrorMessage:

            let uniqueId: String = record.uniqueId
            let sortId: UInt64 = record.id
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = SDSDeserialization.optionalString(record.body, name: "body")
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.numeric(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.numeric(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.numeric(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.numeric(record.schemaVersion, name: "schemaVersion")
            let errorMessageSchemaVersion: UInt = try SDSDeserialization.numeric(record.errorMessageSchemaVersion, name: "errorMessageSchemaVersion")
            guard let errorType: TSErrorMessageType = record.errorType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.numeric(record.read, name: "read")
            let recipientId: String? = SDSDeserialization.optionalString(record.recipientId, name: "recipientId")
            let authorId: String = try SDSDeserialization.string(record.authorId, name: "authorId")
            let envelopeData: Data? = SDSDeserialization.optionalData(record.envelopeData, name: "envelopeData")

            return TSInvalidIdentityKeyReceivingErrorMessage(uniqueId: uniqueId,
                                                             receivedAtTimestamp: receivedAtTimestamp,
                                                             sortId: sortId,
                                                             timestamp: timestamp,
                                                             uniqueThreadId: uniqueThreadId,
                                                             attachmentIds: attachmentIds,
                                                             body: body,
                                                             contactShare: contactShare,
                                                             expireStartedAt: expireStartedAt,
                                                             expiresAt: expiresAt,
                                                             expiresInSeconds: expiresInSeconds,
                                                             linkPreview: linkPreview,
                                                             messageSticker: messageSticker,
                                                             quotedMessage: quotedMessage,
                                                             schemaVersion: schemaVersion,
                                                             errorMessageSchemaVersion: errorMessageSchemaVersion,
                                                             errorType: errorType,
                                                             read: read,
                                                             recipientId: recipientId,
                                                             authorId: authorId,
                                                             envelopeData: envelopeData)

        case .invalidIdentityKeySendingErrorMessage:

            let uniqueId: String = record.uniqueId
            let sortId: UInt64 = record.id
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = SDSDeserialization.optionalString(record.body, name: "body")
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.numeric(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.numeric(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.numeric(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.numeric(record.schemaVersion, name: "schemaVersion")
            let errorMessageSchemaVersion: UInt = try SDSDeserialization.numeric(record.errorMessageSchemaVersion, name: "errorMessageSchemaVersion")
            guard let errorType: TSErrorMessageType = record.errorType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.numeric(record.read, name: "read")
            let recipientId: String? = SDSDeserialization.optionalString(record.recipientId, name: "recipientId")
            let messageId: String = try SDSDeserialization.string(record.messageId, name: "messageId")
            let preKeyBundleSerialized: Data? = record.preKeyBundle
            let preKeyBundle: PreKeyBundle = try SDSDeserialization.unarchive(preKeyBundleSerialized, name: "preKeyBundle")

            return TSInvalidIdentityKeySendingErrorMessage(uniqueId: uniqueId,
                                                           receivedAtTimestamp: receivedAtTimestamp,
                                                           sortId: sortId,
                                                           timestamp: timestamp,
                                                           uniqueThreadId: uniqueThreadId,
                                                           attachmentIds: attachmentIds,
                                                           body: body,
                                                           contactShare: contactShare,
                                                           expireStartedAt: expireStartedAt,
                                                           expiresAt: expiresAt,
                                                           expiresInSeconds: expiresInSeconds,
                                                           linkPreview: linkPreview,
                                                           messageSticker: messageSticker,
                                                           quotedMessage: quotedMessage,
                                                           schemaVersion: schemaVersion,
                                                           errorMessageSchemaVersion: errorMessageSchemaVersion,
                                                           errorType: errorType,
                                                           read: read,
                                                           recipientId: recipientId,
                                                           messageId: messageId,
                                                           preKeyBundle: preKeyBundle)

        case .message:

            let uniqueId: String = record.uniqueId
            let sortId: UInt64 = record.id
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = SDSDeserialization.optionalString(record.body, name: "body")
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.numeric(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.numeric(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.numeric(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.numeric(record.schemaVersion, name: "schemaVersion")

            return TSMessage(uniqueId: uniqueId,
                             receivedAtTimestamp: receivedAtTimestamp,
                             sortId: sortId,
                             timestamp: timestamp,
                             uniqueThreadId: uniqueThreadId,
                             attachmentIds: attachmentIds,
                             body: body,
                             contactShare: contactShare,
                             expireStartedAt: expireStartedAt,
                             expiresAt: expiresAt,
                             expiresInSeconds: expiresInSeconds,
                             linkPreview: linkPreview,
                             messageSticker: messageSticker,
                             quotedMessage: quotedMessage,
                             schemaVersion: schemaVersion)

        case .outgoingMessage:

            let uniqueId: String = record.uniqueId
            let sortId: UInt64 = record.id
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = SDSDeserialization.optionalString(record.body, name: "body")
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let expireStartedAt: UInt64 = try SDSDeserialization.numeric(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.numeric(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.numeric(record.expiresInSeconds, name: "expiresInSeconds")
            let linkPreviewSerialized: Data? = record.linkPreview
            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
            let messageStickerSerialized: Data? = record.messageSticker
            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let schemaVersion: UInt = try SDSDeserialization.numeric(record.schemaVersion, name: "schemaVersion")
            let attachmentFilenameMapSerialized: Data? = record.attachmentFilenameMap
            let attachmentFilenameMap: [String: String] = try SDSDeserialization.unarchive(attachmentFilenameMapSerialized, name: "attachmentFilenameMap")
            let customMessage: String? = SDSDeserialization.optionalString(record.customMessage, name: "customMessage")
            guard let groupMetaMessage: TSGroupMetaMessage = record.groupMetaMessage else {
               throw SDSError.missingRequiredField
            }
            let hasLegacyMessageState: Bool = try SDSDeserialization.numeric(record.hasLegacyMessageState, name: "hasLegacyMessageState")
            let hasSyncedTranscript: Bool = try SDSDeserialization.numeric(record.hasSyncedTranscript, name: "hasSyncedTranscript")
            let isFromLinkedDevice: Bool = try SDSDeserialization.numeric(record.isFromLinkedDevice, name: "isFromLinkedDevice")
            let isVoiceMessage: Bool = try SDSDeserialization.numeric(record.isVoiceMessage, name: "isVoiceMessage")
            guard let legacyMessageState: TSOutgoingMessageState = record.legacyMessageState else {
               throw SDSError.missingRequiredField
            }
            let legacyWasDelivered: Bool = try SDSDeserialization.numeric(record.legacyWasDelivered, name: "legacyWasDelivered")
            let mostRecentFailureText: String? = SDSDeserialization.optionalString(record.mostRecentFailureText, name: "mostRecentFailureText")
            let recipientStateMapSerialized: Data? = record.recipientStateMap
            let recipientStateMap: [String: TSOutgoingMessageRecipientState]? = try SDSDeserialization.optionalUnarchive(recipientStateMapSerialized, name: "recipientStateMap")

            return TSOutgoingMessage(uniqueId: uniqueId,
                                     receivedAtTimestamp: receivedAtTimestamp,
                                     sortId: sortId,
                                     timestamp: timestamp,
                                     uniqueThreadId: uniqueThreadId,
                                     attachmentIds: attachmentIds,
                                     body: body,
                                     contactShare: contactShare,
                                     expireStartedAt: expireStartedAt,
                                     expiresAt: expiresAt,
                                     expiresInSeconds: expiresInSeconds,
                                     linkPreview: linkPreview,
                                     messageSticker: messageSticker,
                                     quotedMessage: quotedMessage,
                                     schemaVersion: schemaVersion,
                                     attachmentFilenameMap: attachmentFilenameMap,
                                     customMessage: customMessage,
                                     groupMetaMessage: groupMetaMessage,
                                     hasLegacyMessageState: hasLegacyMessageState,
                                     hasSyncedTranscript: hasSyncedTranscript,
                                     isFromLinkedDevice: isFromLinkedDevice,
                                     isVoiceMessage: isVoiceMessage,
                                     legacyMessageState: legacyMessageState,
                                     legacyWasDelivered: legacyWasDelivered,
                                     mostRecentFailureText: mostRecentFailureText,
                                     recipientStateMap: recipientStateMap)

        case .unreadIndicatorInteraction:

            let uniqueId: String = record.uniqueId
            let sortId: UInt64 = record.id
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId

            return TSUnreadIndicatorInteraction(uniqueId: uniqueId,
                                                receivedAtTimestamp: receivedAtTimestamp,
                                                sortId: sortId,
                                                timestamp: timestamp,
                                                uniqueThreadId: uniqueThreadId)

        default:
            owsFailDebug("Unexpected record type: \(record.recordType)")
            throw SDSError.invalidValue
        }
    }
}

// MARK: - SDSSerializable

extension TSInteraction: SDSSerializable {
    public var serializer: SDSSerializer {
        // Any subclass can be cast to it's superclass,
        // so the order of this switch statement matters.
        // We need to do a "depth first" search by type.
        switch self {
        case let model as TSUnreadIndicatorInteraction:
            assert(type(of: model) == TSUnreadIndicatorInteraction.self)
            return TSUnreadIndicatorInteractionSerializer(model: model)
        case let model as TSOutgoingMessage:
            assert(type(of: model) == TSOutgoingMessage.self)
            return TSOutgoingMessageSerializer(model: model)
        case let model as OWSVerificationStateChangeMessage:
            assert(type(of: model) == OWSVerificationStateChangeMessage.self)
            return OWSVerificationStateChangeMessageSerializer(model: model)
        case let model as OWSDisappearingConfigurationUpdateInfoMessage:
            assert(type(of: model) == OWSDisappearingConfigurationUpdateInfoMessage.self)
            return OWSDisappearingConfigurationUpdateInfoMessageSerializer(model: model)
        case let model as OWSAddToProfileWhitelistOfferMessage:
            assert(type(of: model) == OWSAddToProfileWhitelistOfferMessage.self)
            return OWSAddToProfileWhitelistOfferMessageSerializer(model: model)
        case let model as OWSAddToContactsOfferMessage:
            assert(type(of: model) == OWSAddToContactsOfferMessage.self)
            return OWSAddToContactsOfferMessageSerializer(model: model)
        case let model as TSInfoMessage:
            assert(type(of: model) == TSInfoMessage.self)
            return TSInfoMessageSerializer(model: model)
        case let model as TSIncomingMessage:
            assert(type(of: model) == TSIncomingMessage.self)
            return TSIncomingMessageSerializer(model: model)
        case let model as TSInvalidIdentityKeySendingErrorMessage:
            assert(type(of: model) == TSInvalidIdentityKeySendingErrorMessage.self)
            return TSInvalidIdentityKeySendingErrorMessageSerializer(model: model)
        case let model as TSInvalidIdentityKeyReceivingErrorMessage:
            assert(type(of: model) == TSInvalidIdentityKeyReceivingErrorMessage.self)
            return TSInvalidIdentityKeyReceivingErrorMessageSerializer(model: model)
        case let model as TSInvalidIdentityKeyErrorMessage:
            assert(type(of: model) == TSInvalidIdentityKeyErrorMessage.self)
            return TSInvalidIdentityKeyErrorMessageSerializer(model: model)
        case let model as OWSUnknownContactBlockOfferMessage:
            assert(type(of: model) == OWSUnknownContactBlockOfferMessage.self)
            return OWSUnknownContactBlockOfferMessageSerializer(model: model)
        case let model as TSErrorMessage:
            assert(type(of: model) == TSErrorMessage.self)
            return TSErrorMessageSerializer(model: model)
        case let model as TSMessage:
            assert(type(of: model) == TSMessage.self)
            return TSMessageSerializer(model: model)
        case let model as TSCall:
            assert(type(of: model) == TSCall.self)
            return TSCallSerializer(model: model)
        case let model as OWSContactOffersInteraction:
            assert(type(of: model) == OWSContactOffersInteraction.self)
            return OWSContactOffersInteractionSerializer(model: model)
        default:
            return TSInteractionSerializer(model: self)
        }
    }
}

// MARK: - Table Metadata

extension TSInteractionSerializer {

    // This defines all of the columns used in the table
    // where this model (and any subclasses) are persisted.
    static let recordTypeColumn = SDSColumnMetadata(columnName: "recordType", columnType: .int, columnIndex: 0)
    static let idColumn = SDSColumnMetadata(columnName: "id", columnType: .primaryKey, columnIndex: 1)
    static let uniqueIdColumn = SDSColumnMetadata(columnName: "uniqueId", columnType: .unicodeString, columnIndex: 2)
    // Base class properties
    static let receivedAtTimestampColumn = SDSColumnMetadata(columnName: "receivedAtTimestamp", columnType: .int64, columnIndex: 3)
    static let timestampColumn = SDSColumnMetadata(columnName: "timestamp", columnType: .int64, columnIndex: 4)
    static let uniqueThreadIdColumn = SDSColumnMetadata(columnName: "uniqueThreadId", columnType: .unicodeString, columnIndex: 5)
    // Subclass properties
    static let attachmentFilenameMapColumn = SDSColumnMetadata(columnName: "attachmentFilenameMap", columnType: .blob, isOptional: true, columnIndex: 6)
    static let attachmentIdsColumn = SDSColumnMetadata(columnName: "attachmentIds", columnType: .blob, isOptional: true, columnIndex: 7)
    static let authorIdColumn = SDSColumnMetadata(columnName: "authorId", columnType: .unicodeString, isOptional: true, columnIndex: 8)
    static let beforeInteractionIdColumn = SDSColumnMetadata(columnName: "beforeInteractionId", columnType: .unicodeString, isOptional: true, columnIndex: 9)
    static let bodyColumn = SDSColumnMetadata(columnName: "body", columnType: .unicodeString, isOptional: true, columnIndex: 10)
    static let callSchemaVersionColumn = SDSColumnMetadata(columnName: "callSchemaVersion", columnType: .int64, isOptional: true, columnIndex: 11)
    static let callTypeColumn = SDSColumnMetadata(columnName: "callType", columnType: .int, isOptional: true, columnIndex: 12)
    static let configurationDurationSecondsColumn = SDSColumnMetadata(columnName: "configurationDurationSeconds", columnType: .int64, isOptional: true, columnIndex: 13)
    static let configurationIsEnabledColumn = SDSColumnMetadata(columnName: "configurationIsEnabled", columnType: .int, isOptional: true, columnIndex: 14)
    static let contactIdColumn = SDSColumnMetadata(columnName: "contactId", columnType: .unicodeString, isOptional: true, columnIndex: 15)
    static let contactShareColumn = SDSColumnMetadata(columnName: "contactShare", columnType: .blob, isOptional: true, columnIndex: 16)
    static let createdByRemoteNameColumn = SDSColumnMetadata(columnName: "createdByRemoteName", columnType: .unicodeString, isOptional: true, columnIndex: 17)
    static let createdInExistingGroupColumn = SDSColumnMetadata(columnName: "createdInExistingGroup", columnType: .int, isOptional: true, columnIndex: 18)
    static let customMessageColumn = SDSColumnMetadata(columnName: "customMessage", columnType: .unicodeString, isOptional: true, columnIndex: 19)
    static let envelopeDataColumn = SDSColumnMetadata(columnName: "envelopeData", columnType: .blob, isOptional: true, columnIndex: 20)
    static let errorMessageSchemaVersionColumn = SDSColumnMetadata(columnName: "errorMessageSchemaVersion", columnType: .int64, isOptional: true, columnIndex: 21)
    static let errorTypeColumn = SDSColumnMetadata(columnName: "errorType", columnType: .int, isOptional: true, columnIndex: 22)
    static let expireStartedAtColumn = SDSColumnMetadata(columnName: "expireStartedAt", columnType: .int64, isOptional: true, columnIndex: 23)
    static let expiresAtColumn = SDSColumnMetadata(columnName: "expiresAt", columnType: .int64, isOptional: true, columnIndex: 24)
    static let expiresInSecondsColumn = SDSColumnMetadata(columnName: "expiresInSeconds", columnType: .int64, isOptional: true, columnIndex: 25)
    static let groupMetaMessageColumn = SDSColumnMetadata(columnName: "groupMetaMessage", columnType: .int, isOptional: true, columnIndex: 26)
    static let hasAddToContactsOfferColumn = SDSColumnMetadata(columnName: "hasAddToContactsOffer", columnType: .int, isOptional: true, columnIndex: 27)
    static let hasAddToProfileWhitelistOfferColumn = SDSColumnMetadata(columnName: "hasAddToProfileWhitelistOffer", columnType: .int, isOptional: true, columnIndex: 28)
    static let hasBlockOfferColumn = SDSColumnMetadata(columnName: "hasBlockOffer", columnType: .int, isOptional: true, columnIndex: 29)
    static let hasLegacyMessageStateColumn = SDSColumnMetadata(columnName: "hasLegacyMessageState", columnType: .int, isOptional: true, columnIndex: 30)
    static let hasSyncedTranscriptColumn = SDSColumnMetadata(columnName: "hasSyncedTranscript", columnType: .int, isOptional: true, columnIndex: 31)
    static let infoMessageSchemaVersionColumn = SDSColumnMetadata(columnName: "infoMessageSchemaVersion", columnType: .int64, isOptional: true, columnIndex: 32)
    static let isFromLinkedDeviceColumn = SDSColumnMetadata(columnName: "isFromLinkedDevice", columnType: .int, isOptional: true, columnIndex: 33)
    static let isLocalChangeColumn = SDSColumnMetadata(columnName: "isLocalChange", columnType: .int, isOptional: true, columnIndex: 34)
    static let isVoiceMessageColumn = SDSColumnMetadata(columnName: "isVoiceMessage", columnType: .int, isOptional: true, columnIndex: 35)
    static let legacyMessageStateColumn = SDSColumnMetadata(columnName: "legacyMessageState", columnType: .int, isOptional: true, columnIndex: 36)
    static let legacyWasDeliveredColumn = SDSColumnMetadata(columnName: "legacyWasDelivered", columnType: .int, isOptional: true, columnIndex: 37)
    static let linkPreviewColumn = SDSColumnMetadata(columnName: "linkPreview", columnType: .blob, isOptional: true, columnIndex: 38)
    static let messageIdColumn = SDSColumnMetadata(columnName: "messageId", columnType: .unicodeString, isOptional: true, columnIndex: 39)
    static let messageStickerColumn = SDSColumnMetadata(columnName: "messageSticker", columnType: .blob, isOptional: true, columnIndex: 40)
    static let messageTypeColumn = SDSColumnMetadata(columnName: "messageType", columnType: .int, isOptional: true, columnIndex: 41)
    static let mostRecentFailureTextColumn = SDSColumnMetadata(columnName: "mostRecentFailureText", columnType: .unicodeString, isOptional: true, columnIndex: 42)
    static let preKeyBundleColumn = SDSColumnMetadata(columnName: "preKeyBundle", columnType: .blob, isOptional: true, columnIndex: 43)
    static let quotedMessageColumn = SDSColumnMetadata(columnName: "quotedMessage", columnType: .blob, isOptional: true, columnIndex: 44)
    static let readColumn = SDSColumnMetadata(columnName: "read", columnType: .int, isOptional: true, columnIndex: 45)
    static let recipientIdColumn = SDSColumnMetadata(columnName: "recipientId", columnType: .unicodeString, isOptional: true, columnIndex: 46)
    static let recipientStateMapColumn = SDSColumnMetadata(columnName: "recipientStateMap", columnType: .blob, isOptional: true, columnIndex: 47)
    static let schemaVersionColumn = SDSColumnMetadata(columnName: "schemaVersion", columnType: .int64, isOptional: true, columnIndex: 48)
    static let serverTimestampColumn = SDSColumnMetadata(columnName: "serverTimestamp", columnType: .int64, isOptional: true, columnIndex: 49)
    static let sourceDeviceIdColumn = SDSColumnMetadata(columnName: "sourceDeviceId", columnType: .int64, isOptional: true, columnIndex: 50)
    static let unregisteredRecipientIdColumn = SDSColumnMetadata(columnName: "unregisteredRecipientId", columnType: .unicodeString, isOptional: true, columnIndex: 51)
    static let verificationStateColumn = SDSColumnMetadata(columnName: "verificationState", columnType: .int, isOptional: true, columnIndex: 52)
    static let wasReceivedByUDColumn = SDSColumnMetadata(columnName: "wasReceivedByUD", columnType: .int, isOptional: true, columnIndex: 53)

    // TODO: We should decide on a naming convention for
    //       tables that store models.
    public static let table = SDSTableMetadata(tableName: "model_TSInteraction", columns: [
        recordTypeColumn,
        idColumn,
        uniqueIdColumn,
        receivedAtTimestampColumn,
        timestampColumn,
        uniqueThreadIdColumn,
        attachmentFilenameMapColumn,
        attachmentIdsColumn,
        authorIdColumn,
        beforeInteractionIdColumn,
        bodyColumn,
        callSchemaVersionColumn,
        callTypeColumn,
        configurationDurationSecondsColumn,
        configurationIsEnabledColumn,
        contactIdColumn,
        contactShareColumn,
        createdByRemoteNameColumn,
        createdInExistingGroupColumn,
        customMessageColumn,
        envelopeDataColumn,
        errorMessageSchemaVersionColumn,
        errorTypeColumn,
        expireStartedAtColumn,
        expiresAtColumn,
        expiresInSecondsColumn,
        groupMetaMessageColumn,
        hasAddToContactsOfferColumn,
        hasAddToProfileWhitelistOfferColumn,
        hasBlockOfferColumn,
        hasLegacyMessageStateColumn,
        hasSyncedTranscriptColumn,
        infoMessageSchemaVersionColumn,
        isFromLinkedDeviceColumn,
        isLocalChangeColumn,
        isVoiceMessageColumn,
        legacyMessageStateColumn,
        legacyWasDeliveredColumn,
        linkPreviewColumn,
        messageIdColumn,
        messageStickerColumn,
        messageTypeColumn,
        mostRecentFailureTextColumn,
        preKeyBundleColumn,
        quotedMessageColumn,
        readColumn,
        recipientIdColumn,
        recipientStateMapColumn,
        schemaVersionColumn,
        serverTimestampColumn,
        sourceDeviceIdColumn,
        unregisteredRecipientIdColumn,
        verificationStateColumn,
        wasReceivedByUDColumn
        ])

}

// MARK: - Deserialization

extension TSInteractionSerializer {
    // This method defines how to deserialize a model, given a
    // database row.  The recordType column is used to determine
    // the corresponding model class.
    class func sdsDeserialize(statement: SelectStatement) throws -> TSInteraction {

        if OWSIsDebugBuild() {
            guard statement.columnNames == table.selectColumnNames else {
                owsFailDebug("Unexpected columns: \(statement.columnNames) != \(table.selectColumnNames)")
                throw SDSError.invalidResult
            }
        }

        // SDSDeserializer is used to convert column values into Swift values.
        let deserializer = SDSDeserializer(sqliteStatement: statement.sqliteStatement)
        let recordTypeValue = try deserializer.int(at: 0)
        guard let recordType = SDSRecordType(rawValue: UInt(recordTypeValue)) else {
            owsFailDebug("Invalid recordType: \(recordTypeValue)")
            throw SDSError.invalidResult
        }
        switch recordType {
        case .addToContactsOfferMessage:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: idColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))
            let customMessage = try deserializer.optionalString(at: customMessageColumn.columnIndex)
            let infoMessageSchemaVersion = UInt(try deserializer.int64(at: infoMessageSchemaVersionColumn.columnIndex))
            let messageTypeRaw = Int(try deserializer.int(at: messageTypeColumn.columnIndex))
            guard let messageType = TSInfoMessageType(rawValue: messageTypeRaw) else {
               throw SDSError.invalidValue
            }
            let read = try deserializer.bool(at: readColumn.columnIndex)
            let unregisteredRecipientId = try deserializer.optionalString(at: unregisteredRecipientIdColumn.columnIndex)
            let contactId = try deserializer.string(at: contactIdColumn.columnIndex)

            return OWSAddToContactsOfferMessage(uniqueId: uniqueId,
                                                receivedAtTimestamp: receivedAtTimestamp,
                                                sortId: sortId,
                                                timestamp: timestamp,
                                                uniqueThreadId: uniqueThreadId,
                                                attachmentIds: attachmentIds,
                                                body: body,
                                                contactShare: contactShare,
                                                expireStartedAt: expireStartedAt,
                                                expiresAt: expiresAt,
                                                expiresInSeconds: expiresInSeconds,
                                                linkPreview: linkPreview,
                                                messageSticker: messageSticker,
                                                quotedMessage: quotedMessage,
                                                schemaVersion: schemaVersion,
                                                customMessage: customMessage,
                                                infoMessageSchemaVersion: infoMessageSchemaVersion,
                                                messageType: messageType,
                                                read: read,
                                                unregisteredRecipientId: unregisteredRecipientId,
                                                contactId: contactId)

        case .addToProfileWhitelistOfferMessage:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: idColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))
            let customMessage = try deserializer.optionalString(at: customMessageColumn.columnIndex)
            let infoMessageSchemaVersion = UInt(try deserializer.int64(at: infoMessageSchemaVersionColumn.columnIndex))
            let messageTypeRaw = Int(try deserializer.int(at: messageTypeColumn.columnIndex))
            guard let messageType = TSInfoMessageType(rawValue: messageTypeRaw) else {
               throw SDSError.invalidValue
            }
            let read = try deserializer.bool(at: readColumn.columnIndex)
            let unregisteredRecipientId = try deserializer.optionalString(at: unregisteredRecipientIdColumn.columnIndex)
            let contactId = try deserializer.string(at: contactIdColumn.columnIndex)

            return OWSAddToProfileWhitelistOfferMessage(uniqueId: uniqueId,
                                                        receivedAtTimestamp: receivedAtTimestamp,
                                                        sortId: sortId,
                                                        timestamp: timestamp,
                                                        uniqueThreadId: uniqueThreadId,
                                                        attachmentIds: attachmentIds,
                                                        body: body,
                                                        contactShare: contactShare,
                                                        expireStartedAt: expireStartedAt,
                                                        expiresAt: expiresAt,
                                                        expiresInSeconds: expiresInSeconds,
                                                        linkPreview: linkPreview,
                                                        messageSticker: messageSticker,
                                                        quotedMessage: quotedMessage,
                                                        schemaVersion: schemaVersion,
                                                        customMessage: customMessage,
                                                        infoMessageSchemaVersion: infoMessageSchemaVersion,
                                                        messageType: messageType,
                                                        read: read,
                                                        unregisteredRecipientId: unregisteredRecipientId,
                                                        contactId: contactId)

        case .contactOffersInteraction:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: idColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let beforeInteractionId = try deserializer.string(at: beforeInteractionIdColumn.columnIndex)
            let hasAddToContactsOffer = try deserializer.bool(at: hasAddToContactsOfferColumn.columnIndex)
            let hasAddToProfileWhitelistOffer = try deserializer.bool(at: hasAddToProfileWhitelistOfferColumn.columnIndex)
            let hasBlockOffer = try deserializer.bool(at: hasBlockOfferColumn.columnIndex)
            let recipientId = try deserializer.string(at: recipientIdColumn.columnIndex)

            return OWSContactOffersInteraction(uniqueId: uniqueId,
                                               receivedAtTimestamp: receivedAtTimestamp,
                                               sortId: sortId,
                                               timestamp: timestamp,
                                               uniqueThreadId: uniqueThreadId,
                                               beforeInteractionId: beforeInteractionId,
                                               hasAddToContactsOffer: hasAddToContactsOffer,
                                               hasAddToProfileWhitelistOffer: hasAddToProfileWhitelistOffer,
                                               hasBlockOffer: hasBlockOffer,
                                               recipientId: recipientId)

        case .disappearingConfigurationUpdateInfoMessage:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: idColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))
            let customMessage = try deserializer.optionalString(at: customMessageColumn.columnIndex)
            let infoMessageSchemaVersion = UInt(try deserializer.int64(at: infoMessageSchemaVersionColumn.columnIndex))
            let messageTypeRaw = Int(try deserializer.int(at: messageTypeColumn.columnIndex))
            guard let messageType = TSInfoMessageType(rawValue: messageTypeRaw) else {
               throw SDSError.invalidValue
            }
            let read = try deserializer.bool(at: readColumn.columnIndex)
            let unregisteredRecipientId = try deserializer.optionalString(at: unregisteredRecipientIdColumn.columnIndex)
            let configurationDurationSeconds = UInt32(try deserializer.int64(at: configurationDurationSecondsColumn.columnIndex))
            let configurationIsEnabled = try deserializer.bool(at: configurationIsEnabledColumn.columnIndex)
            let createdByRemoteName = try deserializer.optionalString(at: createdByRemoteNameColumn.columnIndex)
            let createdInExistingGroup = try deserializer.bool(at: createdInExistingGroupColumn.columnIndex)

            return OWSDisappearingConfigurationUpdateInfoMessage(uniqueId: uniqueId,
                                                                 receivedAtTimestamp: receivedAtTimestamp,
                                                                 sortId: sortId,
                                                                 timestamp: timestamp,
                                                                 uniqueThreadId: uniqueThreadId,
                                                                 attachmentIds: attachmentIds,
                                                                 body: body,
                                                                 contactShare: contactShare,
                                                                 expireStartedAt: expireStartedAt,
                                                                 expiresAt: expiresAt,
                                                                 expiresInSeconds: expiresInSeconds,
                                                                 linkPreview: linkPreview,
                                                                 messageSticker: messageSticker,
                                                                 quotedMessage: quotedMessage,
                                                                 schemaVersion: schemaVersion,
                                                                 customMessage: customMessage,
                                                                 infoMessageSchemaVersion: infoMessageSchemaVersion,
                                                                 messageType: messageType,
                                                                 read: read,
                                                                 unregisteredRecipientId: unregisteredRecipientId,
                                                                 configurationDurationSeconds: configurationDurationSeconds,
                                                                 configurationIsEnabled: configurationIsEnabled,
                                                                 createdByRemoteName: createdByRemoteName,
                                                                 createdInExistingGroup: createdInExistingGroup)

        case .unknownContactBlockOfferMessage:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: idColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))
            let errorMessageSchemaVersion = UInt(try deserializer.int64(at: errorMessageSchemaVersionColumn.columnIndex))
            let errorTypeRaw = Int32(try deserializer.int(at: errorTypeColumn.columnIndex))
            guard let errorType = TSErrorMessageType(rawValue: errorTypeRaw) else {
               throw SDSError.invalidValue
            }
            let read = try deserializer.bool(at: readColumn.columnIndex)
            let recipientId = try deserializer.optionalString(at: recipientIdColumn.columnIndex)
            let contactId = try deserializer.string(at: contactIdColumn.columnIndex)

            return OWSUnknownContactBlockOfferMessage(uniqueId: uniqueId,
                                                      receivedAtTimestamp: receivedAtTimestamp,
                                                      sortId: sortId,
                                                      timestamp: timestamp,
                                                      uniqueThreadId: uniqueThreadId,
                                                      attachmentIds: attachmentIds,
                                                      body: body,
                                                      contactShare: contactShare,
                                                      expireStartedAt: expireStartedAt,
                                                      expiresAt: expiresAt,
                                                      expiresInSeconds: expiresInSeconds,
                                                      linkPreview: linkPreview,
                                                      messageSticker: messageSticker,
                                                      quotedMessage: quotedMessage,
                                                      schemaVersion: schemaVersion,
                                                      errorMessageSchemaVersion: errorMessageSchemaVersion,
                                                      errorType: errorType,
                                                      read: read,
                                                      recipientId: recipientId,
                                                      contactId: contactId)

        case .verificationStateChangeMessage:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: idColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))
            let customMessage = try deserializer.optionalString(at: customMessageColumn.columnIndex)
            let infoMessageSchemaVersion = UInt(try deserializer.int64(at: infoMessageSchemaVersionColumn.columnIndex))
            let messageTypeRaw = Int(try deserializer.int(at: messageTypeColumn.columnIndex))
            guard let messageType = TSInfoMessageType(rawValue: messageTypeRaw) else {
               throw SDSError.invalidValue
            }
            let read = try deserializer.bool(at: readColumn.columnIndex)
            let unregisteredRecipientId = try deserializer.optionalString(at: unregisteredRecipientIdColumn.columnIndex)
            let isLocalChange = try deserializer.bool(at: isLocalChangeColumn.columnIndex)
            let recipientId = try deserializer.string(at: recipientIdColumn.columnIndex)
            let verificationStateRaw = UInt(try deserializer.int(at: verificationStateColumn.columnIndex))
            guard let verificationState = OWSVerificationState(rawValue: verificationStateRaw) else {
               throw SDSError.invalidValue
            }

            return OWSVerificationStateChangeMessage(uniqueId: uniqueId,
                                                     receivedAtTimestamp: receivedAtTimestamp,
                                                     sortId: sortId,
                                                     timestamp: timestamp,
                                                     uniqueThreadId: uniqueThreadId,
                                                     attachmentIds: attachmentIds,
                                                     body: body,
                                                     contactShare: contactShare,
                                                     expireStartedAt: expireStartedAt,
                                                     expiresAt: expiresAt,
                                                     expiresInSeconds: expiresInSeconds,
                                                     linkPreview: linkPreview,
                                                     messageSticker: messageSticker,
                                                     quotedMessage: quotedMessage,
                                                     schemaVersion: schemaVersion,
                                                     customMessage: customMessage,
                                                     infoMessageSchemaVersion: infoMessageSchemaVersion,
                                                     messageType: messageType,
                                                     read: read,
                                                     unregisteredRecipientId: unregisteredRecipientId,
                                                     isLocalChange: isLocalChange,
                                                     recipientId: recipientId,
                                                     verificationState: verificationState)

        case .call:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: idColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let callSchemaVersion = UInt(try deserializer.int64(at: callSchemaVersionColumn.columnIndex))
            let callTypeRaw = UInt(try deserializer.int(at: callTypeColumn.columnIndex))
            guard let callType = RPRecentCallType(rawValue: callTypeRaw) else {
               throw SDSError.invalidValue
            }
            let read = try deserializer.bool(at: readColumn.columnIndex)

            return TSCall(uniqueId: uniqueId,
                          receivedAtTimestamp: receivedAtTimestamp,
                          sortId: sortId,
                          timestamp: timestamp,
                          uniqueThreadId: uniqueThreadId,
                          callSchemaVersion: callSchemaVersion,
                          callType: callType,
                          read: read)

        case .errorMessage:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: idColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))
            let errorMessageSchemaVersion = UInt(try deserializer.int64(at: errorMessageSchemaVersionColumn.columnIndex))
            let errorTypeRaw = Int32(try deserializer.int(at: errorTypeColumn.columnIndex))
            guard let errorType = TSErrorMessageType(rawValue: errorTypeRaw) else {
               throw SDSError.invalidValue
            }
            let read = try deserializer.bool(at: readColumn.columnIndex)
            let recipientId = try deserializer.optionalString(at: recipientIdColumn.columnIndex)

            return TSErrorMessage(uniqueId: uniqueId,
                                  receivedAtTimestamp: receivedAtTimestamp,
                                  sortId: sortId,
                                  timestamp: timestamp,
                                  uniqueThreadId: uniqueThreadId,
                                  attachmentIds: attachmentIds,
                                  body: body,
                                  contactShare: contactShare,
                                  expireStartedAt: expireStartedAt,
                                  expiresAt: expiresAt,
                                  expiresInSeconds: expiresInSeconds,
                                  linkPreview: linkPreview,
                                  messageSticker: messageSticker,
                                  quotedMessage: quotedMessage,
                                  schemaVersion: schemaVersion,
                                  errorMessageSchemaVersion: errorMessageSchemaVersion,
                                  errorType: errorType,
                                  read: read,
                                  recipientId: recipientId)

        case .incomingMessage:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: idColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))
            let authorId = try deserializer.string(at: authorIdColumn.columnIndex)
            let read = try deserializer.bool(at: readColumn.columnIndex)
            let serverTimestamp = try deserializer.optionalUInt64AsNSNumber(at: serverTimestampColumn.columnIndex)
            let sourceDeviceId = UInt32(try deserializer.int64(at: sourceDeviceIdColumn.columnIndex))
            let wasReceivedByUD = try deserializer.bool(at: wasReceivedByUDColumn.columnIndex)

            return TSIncomingMessage(uniqueId: uniqueId,
                                     receivedAtTimestamp: receivedAtTimestamp,
                                     sortId: sortId,
                                     timestamp: timestamp,
                                     uniqueThreadId: uniqueThreadId,
                                     attachmentIds: attachmentIds,
                                     body: body,
                                     contactShare: contactShare,
                                     expireStartedAt: expireStartedAt,
                                     expiresAt: expiresAt,
                                     expiresInSeconds: expiresInSeconds,
                                     linkPreview: linkPreview,
                                     messageSticker: messageSticker,
                                     quotedMessage: quotedMessage,
                                     schemaVersion: schemaVersion,
                                     authorId: authorId,
                                     read: read,
                                     serverTimestamp: serverTimestamp,
                                     sourceDeviceId: sourceDeviceId,
                                     wasReceivedByUD: wasReceivedByUD)

        case .infoMessage:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: idColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))
            let customMessage = try deserializer.optionalString(at: customMessageColumn.columnIndex)
            let infoMessageSchemaVersion = UInt(try deserializer.int64(at: infoMessageSchemaVersionColumn.columnIndex))
            let messageTypeRaw = Int(try deserializer.int(at: messageTypeColumn.columnIndex))
            guard let messageType = TSInfoMessageType(rawValue: messageTypeRaw) else {
               throw SDSError.invalidValue
            }
            let read = try deserializer.bool(at: readColumn.columnIndex)
            let unregisteredRecipientId = try deserializer.optionalString(at: unregisteredRecipientIdColumn.columnIndex)

            return TSInfoMessage(uniqueId: uniqueId,
                                 receivedAtTimestamp: receivedAtTimestamp,
                                 sortId: sortId,
                                 timestamp: timestamp,
                                 uniqueThreadId: uniqueThreadId,
                                 attachmentIds: attachmentIds,
                                 body: body,
                                 contactShare: contactShare,
                                 expireStartedAt: expireStartedAt,
                                 expiresAt: expiresAt,
                                 expiresInSeconds: expiresInSeconds,
                                 linkPreview: linkPreview,
                                 messageSticker: messageSticker,
                                 quotedMessage: quotedMessage,
                                 schemaVersion: schemaVersion,
                                 customMessage: customMessage,
                                 infoMessageSchemaVersion: infoMessageSchemaVersion,
                                 messageType: messageType,
                                 read: read,
                                 unregisteredRecipientId: unregisteredRecipientId)

        case .interaction:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: idColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)

            return TSInteraction(uniqueId: uniqueId,
                                 receivedAtTimestamp: receivedAtTimestamp,
                                 sortId: sortId,
                                 timestamp: timestamp,
                                 uniqueThreadId: uniqueThreadId)

        case .invalidIdentityKeyErrorMessage:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: idColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))
            let errorMessageSchemaVersion = UInt(try deserializer.int64(at: errorMessageSchemaVersionColumn.columnIndex))
            let errorTypeRaw = Int32(try deserializer.int(at: errorTypeColumn.columnIndex))
            guard let errorType = TSErrorMessageType(rawValue: errorTypeRaw) else {
               throw SDSError.invalidValue
            }
            let read = try deserializer.bool(at: readColumn.columnIndex)
            let recipientId = try deserializer.optionalString(at: recipientIdColumn.columnIndex)

            return TSInvalidIdentityKeyErrorMessage(uniqueId: uniqueId,
                                                    receivedAtTimestamp: receivedAtTimestamp,
                                                    sortId: sortId,
                                                    timestamp: timestamp,
                                                    uniqueThreadId: uniqueThreadId,
                                                    attachmentIds: attachmentIds,
                                                    body: body,
                                                    contactShare: contactShare,
                                                    expireStartedAt: expireStartedAt,
                                                    expiresAt: expiresAt,
                                                    expiresInSeconds: expiresInSeconds,
                                                    linkPreview: linkPreview,
                                                    messageSticker: messageSticker,
                                                    quotedMessage: quotedMessage,
                                                    schemaVersion: schemaVersion,
                                                    errorMessageSchemaVersion: errorMessageSchemaVersion,
                                                    errorType: errorType,
                                                    read: read,
                                                    recipientId: recipientId)

        case .invalidIdentityKeyReceivingErrorMessage:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: idColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))
            let errorMessageSchemaVersion = UInt(try deserializer.int64(at: errorMessageSchemaVersionColumn.columnIndex))
            let errorTypeRaw = Int32(try deserializer.int(at: errorTypeColumn.columnIndex))
            guard let errorType = TSErrorMessageType(rawValue: errorTypeRaw) else {
               throw SDSError.invalidValue
            }
            let read = try deserializer.bool(at: readColumn.columnIndex)
            let recipientId = try deserializer.optionalString(at: recipientIdColumn.columnIndex)
            let authorId = try deserializer.string(at: authorIdColumn.columnIndex)
            let envelopeData = try deserializer.optionalBlob(at: envelopeDataColumn.columnIndex)

            return TSInvalidIdentityKeyReceivingErrorMessage(uniqueId: uniqueId,
                                                             receivedAtTimestamp: receivedAtTimestamp,
                                                             sortId: sortId,
                                                             timestamp: timestamp,
                                                             uniqueThreadId: uniqueThreadId,
                                                             attachmentIds: attachmentIds,
                                                             body: body,
                                                             contactShare: contactShare,
                                                             expireStartedAt: expireStartedAt,
                                                             expiresAt: expiresAt,
                                                             expiresInSeconds: expiresInSeconds,
                                                             linkPreview: linkPreview,
                                                             messageSticker: messageSticker,
                                                             quotedMessage: quotedMessage,
                                                             schemaVersion: schemaVersion,
                                                             errorMessageSchemaVersion: errorMessageSchemaVersion,
                                                             errorType: errorType,
                                                             read: read,
                                                             recipientId: recipientId,
                                                             authorId: authorId,
                                                             envelopeData: envelopeData)

        case .invalidIdentityKeySendingErrorMessage:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: idColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))
            let errorMessageSchemaVersion = UInt(try deserializer.int64(at: errorMessageSchemaVersionColumn.columnIndex))
            let errorTypeRaw = Int32(try deserializer.int(at: errorTypeColumn.columnIndex))
            guard let errorType = TSErrorMessageType(rawValue: errorTypeRaw) else {
               throw SDSError.invalidValue
            }
            let read = try deserializer.bool(at: readColumn.columnIndex)
            let recipientId = try deserializer.optionalString(at: recipientIdColumn.columnIndex)
            let messageId = try deserializer.string(at: messageIdColumn.columnIndex)
            let preKeyBundleSerialized: Data = try deserializer.blob(at: preKeyBundleColumn.columnIndex)
            let preKeyBundle: PreKeyBundle = try SDSDeserializer.unarchive(preKeyBundleSerialized)

            return TSInvalidIdentityKeySendingErrorMessage(uniqueId: uniqueId,
                                                           receivedAtTimestamp: receivedAtTimestamp,
                                                           sortId: sortId,
                                                           timestamp: timestamp,
                                                           uniqueThreadId: uniqueThreadId,
                                                           attachmentIds: attachmentIds,
                                                           body: body,
                                                           contactShare: contactShare,
                                                           expireStartedAt: expireStartedAt,
                                                           expiresAt: expiresAt,
                                                           expiresInSeconds: expiresInSeconds,
                                                           linkPreview: linkPreview,
                                                           messageSticker: messageSticker,
                                                           quotedMessage: quotedMessage,
                                                           schemaVersion: schemaVersion,
                                                           errorMessageSchemaVersion: errorMessageSchemaVersion,
                                                           errorType: errorType,
                                                           read: read,
                                                           recipientId: recipientId,
                                                           messageId: messageId,
                                                           preKeyBundle: preKeyBundle)

        case .message:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: idColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))

            return TSMessage(uniqueId: uniqueId,
                             receivedAtTimestamp: receivedAtTimestamp,
                             sortId: sortId,
                             timestamp: timestamp,
                             uniqueThreadId: uniqueThreadId,
                             attachmentIds: attachmentIds,
                             body: body,
                             contactShare: contactShare,
                             expireStartedAt: expireStartedAt,
                             expiresAt: expiresAt,
                             expiresInSeconds: expiresInSeconds,
                             linkPreview: linkPreview,
                             messageSticker: messageSticker,
                             quotedMessage: quotedMessage,
                             schemaVersion: schemaVersion)

        case .outgoingMessage:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: idColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))
            let attachmentFilenameMapSerialized: Data = try deserializer.blob(at: attachmentFilenameMapColumn.columnIndex)
            let attachmentFilenameMap: [String: String] = try SDSDeserializer.unarchive(attachmentFilenameMapSerialized)
            let customMessage = try deserializer.optionalString(at: customMessageColumn.columnIndex)
            let groupMetaMessageRaw = Int(try deserializer.int(at: groupMetaMessageColumn.columnIndex))
            guard let groupMetaMessage = TSGroupMetaMessage(rawValue: groupMetaMessageRaw) else {
               throw SDSError.invalidValue
            }
            let hasLegacyMessageState = try deserializer.bool(at: hasLegacyMessageStateColumn.columnIndex)
            let hasSyncedTranscript = try deserializer.bool(at: hasSyncedTranscriptColumn.columnIndex)
            let isFromLinkedDevice = try deserializer.bool(at: isFromLinkedDeviceColumn.columnIndex)
            let isVoiceMessage = try deserializer.bool(at: isVoiceMessageColumn.columnIndex)
            let legacyMessageStateRaw = Int(try deserializer.int(at: legacyMessageStateColumn.columnIndex))
            guard let legacyMessageState = TSOutgoingMessageState(rawValue: legacyMessageStateRaw) else {
               throw SDSError.invalidValue
            }
            let legacyWasDelivered = try deserializer.bool(at: legacyWasDeliveredColumn.columnIndex)
            let mostRecentFailureText = try deserializer.optionalString(at: mostRecentFailureTextColumn.columnIndex)
            let recipientStateMapSerialized: Data? = try deserializer.optionalBlob(at: recipientStateMapColumn.columnIndex)
            let recipientStateMap: [String: TSOutgoingMessageRecipientState]? = try SDSDeserializer.optionalUnarchive(recipientStateMapSerialized)

            return TSOutgoingMessage(uniqueId: uniqueId,
                                     receivedAtTimestamp: receivedAtTimestamp,
                                     sortId: sortId,
                                     timestamp: timestamp,
                                     uniqueThreadId: uniqueThreadId,
                                     attachmentIds: attachmentIds,
                                     body: body,
                                     contactShare: contactShare,
                                     expireStartedAt: expireStartedAt,
                                     expiresAt: expiresAt,
                                     expiresInSeconds: expiresInSeconds,
                                     linkPreview: linkPreview,
                                     messageSticker: messageSticker,
                                     quotedMessage: quotedMessage,
                                     schemaVersion: schemaVersion,
                                     attachmentFilenameMap: attachmentFilenameMap,
                                     customMessage: customMessage,
                                     groupMetaMessage: groupMetaMessage,
                                     hasLegacyMessageState: hasLegacyMessageState,
                                     hasSyncedTranscript: hasSyncedTranscript,
                                     isFromLinkedDevice: isFromLinkedDevice,
                                     isVoiceMessage: isVoiceMessage,
                                     legacyMessageState: legacyMessageState,
                                     legacyWasDelivered: legacyWasDelivered,
                                     mostRecentFailureText: mostRecentFailureText,
                                     recipientStateMap: recipientStateMap)

        case .unreadIndicatorInteraction:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: idColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)

            return TSUnreadIndicatorInteraction(uniqueId: uniqueId,
                                                receivedAtTimestamp: receivedAtTimestamp,
                                                sortId: sortId,
                                                timestamp: timestamp,
                                                uniqueThreadId: uniqueThreadId)

        default:
            owsFail("Invalid record type \(recordType)")
        }
    }
}

// MARK: - Save/Remove/Update

@objc
extension TSInteraction {
    public func anySave(transaction: SDSAnyWriteTransaction) {
        switch transaction.writeTransaction {
        case .yapWrite(let ydbTransaction):
            save(with: ydbTransaction)
        case .grdbWrite(let grdbTransaction):
            SDSSerialization.save(entity: self, transaction: grdbTransaction)
        }
    }

    // This method is used by "updateWith..." methods.
    //
    // This model may be updated from many threads. We don't want to save
    // our local copy (this instance) since it may be out of date.  We also
    // want to avoid re-saving a model that has been deleted.  Therefore, we
    // use "updateWith..." methods to:
    //
    // a) Update a property of this instance.
    // b) If a copy of this model exists in the database, load an up-to-date copy,
    //    and update and save that copy.
    // b) If a copy of this model _DOES NOT_ exist in the database, do _NOT_ save
    //    this local instance.
    //
    // After "updateWith...":
    //
    // a) Any copy of this model in the database will have been updated.
    // b) The local property on this instance will always have been updated.
    // c) Other properties on this instance may be out of date.
    //
    // All mutable properties of this class have been made read-only to
    // prevent accidentally modifying them directly.
    //
    // This isn't a perfect arrangement, but in practice this will prevent
    // data loss and will resolve all known issues.
    public func anyUpdateWith(transaction: SDSAnyWriteTransaction, block: (TSInteraction) -> Void) {
        guard let uniqueId = uniqueId else {
            owsFailDebug("Missing uniqueId.")
            return
        }

        guard let dbCopy = type(of: self).anyFetch(uniqueId: uniqueId,
                                                   transaction: transaction) else {
            return
        }

        block(self)
        block(dbCopy)

        dbCopy.anySave(transaction: transaction)
    }

    public func anyRemove(transaction: SDSAnyWriteTransaction) {
        switch transaction.writeTransaction {
        case .yapWrite(let ydbTransaction):
            remove(with: ydbTransaction)
        case .grdbWrite(let grdbTransaction):
            SDSSerialization.delete(entity: self, transaction: grdbTransaction)
        }
    }
}

// MARK: - TSInteractionCursor

@objc
public class TSInteractionCursor: NSObject {
    private let cursor: SDSCursor<TSInteraction>

    init(cursor: SDSCursor<TSInteraction>) {
        self.cursor = cursor
    }

    // TODO: Revisit error handling in this class.
    public func next() throws -> TSInteraction? {
        return try cursor.next()
    }

    public func all() throws -> [TSInteraction] {
        return try cursor.all()
    }
}

// MARK: - Obj-C Fetch

// TODO: We may eventually want to define some combination of:
//
// * fetchCursor, fetchOne, fetchAll, etc. (ala GRDB)
// * Optional "where clause" parameters for filtering.
// * Async flavors with completions.
//
// TODO: I've defined flavors that take a read transaction.
//       Or we might take a "connection" if we end up having that class.
@objc
extension TSInteraction {
    public class func grdbFetchCursor(transaction: GRDBReadTransaction) -> TSInteractionCursor {
        return TSInteractionCursor(cursor: SDSSerialization.fetchCursor(tableMetadata: TSInteractionSerializer.table,
                                                                   transaction: transaction,
                                                                   deserialize: TSInteractionSerializer.sdsDeserialize))
    }

    // Fetches a single model by "unique id".
    public class func anyFetch(uniqueId: String,
                               transaction: SDSAnyReadTransaction) -> TSInteraction? {
        assert(uniqueId.count > 0)

        switch transaction.readTransaction {
        case .yapRead(let ydbTransaction):
            return TSInteraction.fetch(uniqueId: uniqueId, transaction: ydbTransaction)
        case .grdbRead(let grdbTransaction):
            let sql = "SELECT * FROM \(InteractionRecord.databaseTableName) WHERE \(columnForInteraction: .uniqueId) = ?"
            return grdbFetchOne(sql: sql, arguments: [uniqueId], transaction: grdbTransaction)
        }
    }

    // Traverses all records.
    // Records are not visited in any particular order.
    // Traversal aborts if the visitor returns false.
    public class func anyVisitAll(transaction: SDSAnyReadTransaction, visitor: @escaping (TSInteraction) -> Bool) {
        switch transaction.readTransaction {
        case .yapRead(let ydbTransaction):
            TSInteraction.enumerateCollectionObjects(with: ydbTransaction) { (object, stop) in
                guard let value = object as? TSInteraction else {
                    owsFailDebug("unexpected object: \(type(of: object))")
                    return
                }
                guard visitor(value) else {
                    stop.pointee = true
                    return
                }
            }
        case .grdbRead(let grdbTransaction):
            do {
                let cursor = TSInteraction.grdbFetchCursor(transaction: grdbTransaction)
                while let value = try cursor.next() {
                    guard visitor(value) else {
                        return
                    }
                }
            } catch let error as NSError {
                owsFailDebug("Couldn't fetch models: \(error)")
            }
        }
    }

    // Does not order the results.
    public class func anyFetchAll(transaction: SDSAnyReadTransaction) -> [TSInteraction] {
        var result = [TSInteraction]()
        anyVisitAll(transaction: transaction) { (model) in
            result.append(model)
            return true
        }
        return result
    }
}

// MARK: - Swift Fetch

extension TSInteraction {
    public class func grdbFetchCursor(sql: String,
                                      arguments: [DatabaseValueConvertible]?,
                                      transaction: GRDBReadTransaction) -> TSInteractionCursor {
        var statementArguments: StatementArguments?
        if let arguments = arguments {
            guard let statementArgs = StatementArguments(arguments) else {
                owsFail("Could not convert arguments.")
            }
            statementArguments = statementArgs
        }
        return TSInteractionCursor(cursor: SDSSerialization.fetchCursor(sql: sql,
                                                             arguments: statementArguments,
                                                             transaction: transaction,
                                                                   deserialize: TSInteractionSerializer.sdsDeserialize))
    }

    public class func grdbFetchOne(sql: String,
                                   arguments: StatementArguments,
                                   transaction: GRDBReadTransaction) -> TSInteraction? {
        assert(sql.count > 0)

        do {
            guard let record = try InteractionRecord.fetchOne(transaction.database, sql: sql, arguments: arguments) else {
                    return nil
            }

            return try TSInteraction.fromRecord(record)
        } catch {
            owsFailDebug("error: \(error)")
            return nil
        }
    }
}

// MARK: - SDSSerializer

// The SDSSerializer protocol specifies how to insert and update the
// row that corresponds to this model.
class TSInteractionSerializer: SDSSerializer {

    private let model: TSInteraction
    public required init(model: TSInteraction) {
        self.model = model
    }

    public func serializableColumnTableMetadata() -> SDSTableMetadata {
        return TSInteractionSerializer.table
    }

    public func insertColumnNames() -> [String] {
        // When we insert a new row, we include the following columns:
        //
        // * "record type"
        // * "unique id"
        // * ...all columns that we set when updating.
        return [
            TSInteractionSerializer.recordTypeColumn.columnName,
            uniqueIdColumnName()
            ] + updateColumnNames()

    }

    public func insertColumnValues() -> [DatabaseValueConvertible] {
        let result: [DatabaseValueConvertible] = [
            SDSRecordType.interaction.rawValue
            ] + [uniqueIdColumnValue()] + updateColumnValues()
        if OWSIsDebugBuild() {
            if result.count != insertColumnNames().count {
                owsFailDebug("Update mismatch: \(result.count) != \(insertColumnNames().count)")
            }
        }
        return result
    }

    public func updateColumnNames() -> [String] {
        return [
            TSInteractionSerializer.receivedAtTimestampColumn,
            TSInteractionSerializer.timestampColumn,
            TSInteractionSerializer.uniqueThreadIdColumn
            ].map { $0.columnName }
    }

    public func updateColumnValues() -> [DatabaseValueConvertible] {
        let result: [DatabaseValueConvertible] = [
            self.model.receivedAtTimestamp,
            self.model.timestamp,
            self.model.uniqueThreadId

        ]
        if OWSIsDebugBuild() {
            if result.count != updateColumnNames().count {
                owsFailDebug("Update mismatch: \(result.count) != \(updateColumnNames().count)")
            }
        }
        return result
    }

    public func uniqueIdColumnName() -> String {
        return TSInteractionSerializer.uniqueIdColumn.columnName
    }

    // TODO: uniqueId is currently an optional on our models.
    //       We should probably make the return type here String?
    public func uniqueIdColumnValue() -> DatabaseValueConvertible {
        // FIXME remove force unwrap
        return model.uniqueId!
    }
}
