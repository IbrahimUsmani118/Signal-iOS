//
//  Copyright (c) 2019 Open Whisper Systems. All rights reserved.
//

import Foundation
import GRDBCipher
import SignalCoreKit

// NOTE: This file is generated by /Scripts/sds_codegen/sds_generate.py.
// Do not manually edit it, instead run `sds_codegen.sh`.

// MARK: - SDSSerializable

extension TSInteraction: SDSSerializable {
    public var serializer: SDSSerializer {
        // Any subclass can be cast to it's superclass,
        // so the order of this switch statement matters.
        // We need to do a "depth first" search by type.
        switch self {
        case let model as OWSContactOffersInteraction:
            assert(type(of: model) == OWSContactOffersInteraction.self)
            return OWSContactOffersInteractionSerializer(model: model)
        case let model as TSCall:
            assert(type(of: model) == TSCall.self)
            return TSCallSerializer(model: model)
        case let model as TSOutgoingMessage:
            assert(type(of: model) == TSOutgoingMessage.self)
            return TSOutgoingMessageSerializer(model: model)
        case let model as TSIncomingMessage:
            assert(type(of: model) == TSIncomingMessage.self)
            return TSIncomingMessageSerializer(model: model)
        case let model as OWSDisappearingConfigurationUpdateInfoMessage:
            assert(type(of: model) == OWSDisappearingConfigurationUpdateInfoMessage.self)
            return OWSDisappearingConfigurationUpdateInfoMessageSerializer(model: model)
        case let model as OWSAddToContactsOfferMessage:
            assert(type(of: model) == OWSAddToContactsOfferMessage.self)
            return OWSAddToContactsOfferMessageSerializer(model: model)
        case let model as OWSVerificationStateChangeMessage:
            assert(type(of: model) == OWSVerificationStateChangeMessage.self)
            return OWSVerificationStateChangeMessageSerializer(model: model)
        case let model as OWSAddToProfileWhitelistOfferMessage:
            assert(type(of: model) == OWSAddToProfileWhitelistOfferMessage.self)
            return OWSAddToProfileWhitelistOfferMessageSerializer(model: model)
        case let model as TSInfoMessage:
            assert(type(of: model) == TSInfoMessage.self)
            return TSInfoMessageSerializer(model: model)
        case let model as TSInvalidIdentityKeySendingErrorMessage:
            assert(type(of: model) == TSInvalidIdentityKeySendingErrorMessage.self)
            return TSInvalidIdentityKeySendingErrorMessageSerializer(model: model)
        case let model as TSInvalidIdentityKeyReceivingErrorMessage:
            assert(type(of: model) == TSInvalidIdentityKeyReceivingErrorMessage.self)
            return TSInvalidIdentityKeyReceivingErrorMessageSerializer(model: model)
        case let model as TSInvalidIdentityKeyErrorMessage:
            assert(type(of: model) == TSInvalidIdentityKeyErrorMessage.self)
            return TSInvalidIdentityKeyErrorMessageSerializer(model: model)
        case let model as OWSUnknownContactBlockOfferMessage:
            assert(type(of: model) == OWSUnknownContactBlockOfferMessage.self)
            return OWSUnknownContactBlockOfferMessageSerializer(model: model)
        case let model as TSErrorMessage:
            assert(type(of: model) == TSErrorMessage.self)
            return TSErrorMessageSerializer(model: model)
        case let model as TSMessage:
            assert(type(of: model) == TSMessage.self)
            return TSMessageSerializer(model: model)
        case let model as TSUnreadIndicatorInteraction:
            assert(type(of: model) == TSUnreadIndicatorInteraction.self)
            return TSUnreadIndicatorInteractionSerializer(model: model)
        default:
            return TSInteractionSerializer(model: self)
        }
    }
}

// MARK: - Table Metadata

extension TSInteractionSerializer {

    // This defines all of the columns used in the table
    // where this model (and any subclasses) are persisted.
    static let recordTypeColumn = SDSColumnMetadata(columnName: "recordType", columnType: .int, columnIndex: 0)
    static let uniqueIdColumn = SDSColumnMetadata(columnName: "uniqueId", columnType: .unicodeString, columnIndex: 1)
    // Base class properties
    static let receivedAtTimestampColumn = SDSColumnMetadata(columnName: "receivedAtTimestamp", columnType: .int64, columnIndex: 2)
    static let sortIdColumn = SDSColumnMetadata(columnName: "sortId", columnType: .int64, columnIndex: 3)
    static let timestampColumn = SDSColumnMetadata(columnName: "timestamp", columnType: .int64, columnIndex: 4)
    static let uniqueThreadIdColumn = SDSColumnMetadata(columnName: "uniqueThreadId", columnType: .unicodeString, columnIndex: 5)
    // Subclass properties
    static let attachmentFilenameMapColumn = SDSColumnMetadata(columnName: "attachmentFilenameMap", columnType: .blob, isOptional: true, columnIndex: 6)
    static let attachmentIdsColumn = SDSColumnMetadata(columnName: "attachmentIds", columnType: .blob, isOptional: true, columnIndex: 7)
    static let authorIdColumn = SDSColumnMetadata(columnName: "authorId", columnType: .unicodeString, isOptional: true, columnIndex: 8)
    static let beforeInteractionIdColumn = SDSColumnMetadata(columnName: "beforeInteractionId", columnType: .unicodeString, isOptional: true, columnIndex: 9)
    static let bodyColumn = SDSColumnMetadata(columnName: "body", columnType: .unicodeString, isOptional: true, columnIndex: 10)
    static let callSchemaVersionColumn = SDSColumnMetadata(columnName: "callSchemaVersion", columnType: .int64, isOptional: true, columnIndex: 11)
    static let callTypeColumn = SDSColumnMetadata(columnName: "callType", columnType: .int, isOptional: true, columnIndex: 12)
    static let configurationDurationSecondsColumn = SDSColumnMetadata(columnName: "configurationDurationSeconds", columnType: .int, isOptional: true, columnIndex: 13)
    static let configurationIsEnabledColumn = SDSColumnMetadata(columnName: "configurationIsEnabled", columnType: .int, isOptional: true, columnIndex: 14)
    static let contactIdColumn = SDSColumnMetadata(columnName: "contactId", columnType: .unicodeString, isOptional: true, columnIndex: 15)
    static let contactShareColumn = SDSColumnMetadata(columnName: "contactShare", columnType: .blob, isOptional: true, columnIndex: 16)
    static let createdByRemoteNameColumn = SDSColumnMetadata(columnName: "createdByRemoteName", columnType: .unicodeString, isOptional: true, columnIndex: 17)
    static let createdInExistingGroupColumn = SDSColumnMetadata(columnName: "createdInExistingGroup", columnType: .int, isOptional: true, columnIndex: 18)
    static let customMessageColumn = SDSColumnMetadata(columnName: "customMessage", columnType: .unicodeString, isOptional: true, columnIndex: 19)
    static let envelopeDataColumn = SDSColumnMetadata(columnName: "envelopeData", columnType: .blob, isOptional: true, columnIndex: 20)
    static let errorMessageSchemaVersionColumn = SDSColumnMetadata(columnName: "errorMessageSchemaVersion", columnType: .int64, isOptional: true, columnIndex: 21)
    static let errorTypeColumn = SDSColumnMetadata(columnName: "errorType", columnType: .int, isOptional: true, columnIndex: 22)
    static let expireStartedAtColumn = SDSColumnMetadata(columnName: "expireStartedAt", columnType: .int64, isOptional: true, columnIndex: 23)
    static let expiresAtColumn = SDSColumnMetadata(columnName: "expiresAt", columnType: .int64, isOptional: true, columnIndex: 24)
    static let expiresInSecondsColumn = SDSColumnMetadata(columnName: "expiresInSeconds", columnType: .int, isOptional: true, columnIndex: 25)
    static let groupMetaMessageColumn = SDSColumnMetadata(columnName: "groupMetaMessage", columnType: .int, isOptional: true, columnIndex: 26)
    static let hasAddToContactsOfferColumn = SDSColumnMetadata(columnName: "hasAddToContactsOffer", columnType: .int, isOptional: true, columnIndex: 27)
    static let hasAddToProfileWhitelistOfferColumn = SDSColumnMetadata(columnName: "hasAddToProfileWhitelistOffer", columnType: .int, isOptional: true, columnIndex: 28)
    static let hasBlockOfferColumn = SDSColumnMetadata(columnName: "hasBlockOffer", columnType: .int, isOptional: true, columnIndex: 29)
    static let hasLegacyMessageStateColumn = SDSColumnMetadata(columnName: "hasLegacyMessageState", columnType: .int, isOptional: true, columnIndex: 30)
    static let hasSyncedTranscriptColumn = SDSColumnMetadata(columnName: "hasSyncedTranscript", columnType: .int, isOptional: true, columnIndex: 31)
    static let infoMessageSchemaVersionColumn = SDSColumnMetadata(columnName: "infoMessageSchemaVersion", columnType: .int64, isOptional: true, columnIndex: 32)
    static let isFromLinkedDeviceColumn = SDSColumnMetadata(columnName: "isFromLinkedDevice", columnType: .int, isOptional: true, columnIndex: 33)
    static let isLocalChangeColumn = SDSColumnMetadata(columnName: "isLocalChange", columnType: .int, isOptional: true, columnIndex: 34)
    static let isVoiceMessageColumn = SDSColumnMetadata(columnName: "isVoiceMessage", columnType: .int, isOptional: true, columnIndex: 35)
    static let legacyMessageStateColumn = SDSColumnMetadata(columnName: "legacyMessageState", columnType: .int, isOptional: true, columnIndex: 36)
    static let legacyWasDeliveredColumn = SDSColumnMetadata(columnName: "legacyWasDelivered", columnType: .int, isOptional: true, columnIndex: 37)
    static let linkPreviewColumn = SDSColumnMetadata(columnName: "linkPreview", columnType: .blob, isOptional: true, columnIndex: 38)
    static let messageIdColumn = SDSColumnMetadata(columnName: "messageId", columnType: .unicodeString, isOptional: true, columnIndex: 39)
    static let messageStickerColumn = SDSColumnMetadata(columnName: "messageSticker", columnType: .blob, isOptional: true, columnIndex: 40)
    static let messageTypeColumn = SDSColumnMetadata(columnName: "messageType", columnType: .int, isOptional: true, columnIndex: 41)
    static let mostRecentFailureTextColumn = SDSColumnMetadata(columnName: "mostRecentFailureText", columnType: .unicodeString, isOptional: true, columnIndex: 42)
    static let preKeyBundleColumn = SDSColumnMetadata(columnName: "preKeyBundle", columnType: .blob, isOptional: true, columnIndex: 43)
    static let quotedMessageColumn = SDSColumnMetadata(columnName: "quotedMessage", columnType: .blob, isOptional: true, columnIndex: 44)
    static let readColumn = SDSColumnMetadata(columnName: "read", columnType: .int, isOptional: true, columnIndex: 45)
    static let recipientIdColumn = SDSColumnMetadata(columnName: "recipientId", columnType: .unicodeString, isOptional: true, columnIndex: 46)
    static let recipientStateMapColumn = SDSColumnMetadata(columnName: "recipientStateMap", columnType: .blob, isOptional: true, columnIndex: 47)
    static let schemaVersionColumn = SDSColumnMetadata(columnName: "schemaVersion", columnType: .int64, isOptional: true, columnIndex: 48)
    static let serverTimestampColumn = SDSColumnMetadata(columnName: "serverTimestamp", columnType: .int64, isOptional: true, columnIndex: 49)
    static let sourceDeviceIdColumn = SDSColumnMetadata(columnName: "sourceDeviceId", columnType: .int, isOptional: true, columnIndex: 50)
    static let unregisteredRecipientIdColumn = SDSColumnMetadata(columnName: "unregisteredRecipientId", columnType: .unicodeString, isOptional: true, columnIndex: 51)
    static let verificationStateColumn = SDSColumnMetadata(columnName: "verificationState", columnType: .int, isOptional: true, columnIndex: 52)
    static let wasReceivedByUDColumn = SDSColumnMetadata(columnName: "wasReceivedByUD", columnType: .int, isOptional: true, columnIndex: 53)

    // TODO: We should decide on a naming convention for
    //       tables that store models.
    public static let table = SDSTableMetadata(tableName: "model_TSInteraction", columns: [
        recordTypeColumn,
        uniqueIdColumn,
        receivedAtTimestampColumn,
        sortIdColumn,
        timestampColumn,
        uniqueThreadIdColumn,
        attachmentFilenameMapColumn,
        attachmentIdsColumn,
        authorIdColumn,
        beforeInteractionIdColumn,
        bodyColumn,
        callSchemaVersionColumn,
        callTypeColumn,
        configurationDurationSecondsColumn,
        configurationIsEnabledColumn,
        contactIdColumn,
        contactShareColumn,
        createdByRemoteNameColumn,
        createdInExistingGroupColumn,
        customMessageColumn,
        envelopeDataColumn,
        errorMessageSchemaVersionColumn,
        errorTypeColumn,
        expireStartedAtColumn,
        expiresAtColumn,
        expiresInSecondsColumn,
        groupMetaMessageColumn,
        hasAddToContactsOfferColumn,
        hasAddToProfileWhitelistOfferColumn,
        hasBlockOfferColumn,
        hasLegacyMessageStateColumn,
        hasSyncedTranscriptColumn,
        infoMessageSchemaVersionColumn,
        isFromLinkedDeviceColumn,
        isLocalChangeColumn,
        isVoiceMessageColumn,
        legacyMessageStateColumn,
        legacyWasDeliveredColumn,
        linkPreviewColumn,
        messageIdColumn,
        messageStickerColumn,
        messageTypeColumn,
        mostRecentFailureTextColumn,
        preKeyBundleColumn,
        quotedMessageColumn,
        readColumn,
        recipientIdColumn,
        recipientStateMapColumn,
        schemaVersionColumn,
        serverTimestampColumn,
        sourceDeviceIdColumn,
        unregisteredRecipientIdColumn,
        verificationStateColumn,
        wasReceivedByUDColumn
        ])

}

// MARK: - Deserialization

extension TSInteractionSerializer {
    // This method defines how to deserialize a model, given a
    // database row.  The recordType column is used to determine
    // the corresponding model class.
    class func sdsDeserialize(statement: SelectStatement) throws -> TSInteraction {

        if OWSIsDebugBuild() {
            guard statement.columnNames == table.selectColumnNames else {
                owsFailDebug("Unexpected columns: \(statement.columnNames) != \(table.selectColumnNames)")
                throw SDSError.invalidResult
            }
        }

        // SDSDeserializer is used to convert column values into Swift values.
        let deserializer = SDSDeserializer(sqliteStatement: statement.sqliteStatement)
        let recordTypeValue = try deserializer.int(at: 0)
        guard let recordType = SDSRecordType(rawValue: UInt(recordTypeValue)) else {
            owsFailDebug("Invalid recordType: \(recordTypeValue)")
            throw SDSError.invalidResult
        }
        switch recordType {
        case .unreadIndicatorInteraction:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: sortIdColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)

            return TSUnreadIndicatorInteraction(uniqueId: uniqueId,
                                                receivedAtTimestamp: receivedAtTimestamp,
                                                sortId: sortId,
                                                timestamp: timestamp,
                                                uniqueThreadId: uniqueThreadId)

        case .message:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: sortIdColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))

            return TSMessage(uniqueId: uniqueId,
                             receivedAtTimestamp: receivedAtTimestamp,
                             sortId: sortId,
                             timestamp: timestamp,
                             uniqueThreadId: uniqueThreadId,
                             attachmentIds: attachmentIds,
                             body: body,
                             contactShare: contactShare,
                             expireStartedAt: expireStartedAt,
                             expiresAt: expiresAt,
                             expiresInSeconds: expiresInSeconds,
                             linkPreview: linkPreview,
                             messageSticker: messageSticker,
                             quotedMessage: quotedMessage,
                             schemaVersion: schemaVersion)

        case .errorMessage:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: sortIdColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))
            let errorMessageSchemaVersion = UInt(try deserializer.int64(at: errorMessageSchemaVersionColumn.columnIndex))
            let errorTypeRaw = Int32(try deserializer.int(at: errorTypeColumn.columnIndex))
            guard let errorType = TSErrorMessageType(rawValue: errorTypeRaw) else {
               throw SDSError.invalidValue
            }
            let read = try deserializer.bool(at: readColumn.columnIndex)
            let recipientId = try deserializer.optionalString(at: recipientIdColumn.columnIndex)

            return TSErrorMessage(uniqueId: uniqueId,
                                  receivedAtTimestamp: receivedAtTimestamp,
                                  sortId: sortId,
                                  timestamp: timestamp,
                                  uniqueThreadId: uniqueThreadId,
                                  attachmentIds: attachmentIds,
                                  body: body,
                                  contactShare: contactShare,
                                  expireStartedAt: expireStartedAt,
                                  expiresAt: expiresAt,
                                  expiresInSeconds: expiresInSeconds,
                                  linkPreview: linkPreview,
                                  messageSticker: messageSticker,
                                  quotedMessage: quotedMessage,
                                  schemaVersion: schemaVersion,
                                  errorMessageSchemaVersion: errorMessageSchemaVersion,
                                  errorType: errorType,
                                  read: read,
                                  recipientId: recipientId)

        case .unknownContactBlockOfferMessage:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: sortIdColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))
            let errorMessageSchemaVersion = UInt(try deserializer.int64(at: errorMessageSchemaVersionColumn.columnIndex))
            let errorTypeRaw = Int32(try deserializer.int(at: errorTypeColumn.columnIndex))
            guard let errorType = TSErrorMessageType(rawValue: errorTypeRaw) else {
               throw SDSError.invalidValue
            }
            let read = try deserializer.bool(at: readColumn.columnIndex)
            let recipientId = try deserializer.optionalString(at: recipientIdColumn.columnIndex)
            let contactId = try deserializer.string(at: contactIdColumn.columnIndex)

            return OWSUnknownContactBlockOfferMessage(uniqueId: uniqueId,
                                                      receivedAtTimestamp: receivedAtTimestamp,
                                                      sortId: sortId,
                                                      timestamp: timestamp,
                                                      uniqueThreadId: uniqueThreadId,
                                                      attachmentIds: attachmentIds,
                                                      body: body,
                                                      contactShare: contactShare,
                                                      expireStartedAt: expireStartedAt,
                                                      expiresAt: expiresAt,
                                                      expiresInSeconds: expiresInSeconds,
                                                      linkPreview: linkPreview,
                                                      messageSticker: messageSticker,
                                                      quotedMessage: quotedMessage,
                                                      schemaVersion: schemaVersion,
                                                      errorMessageSchemaVersion: errorMessageSchemaVersion,
                                                      errorType: errorType,
                                                      read: read,
                                                      recipientId: recipientId,
                                                      contactId: contactId)

        case .invalidIdentityKeyErrorMessage:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: sortIdColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))
            let errorMessageSchemaVersion = UInt(try deserializer.int64(at: errorMessageSchemaVersionColumn.columnIndex))
            let errorTypeRaw = Int32(try deserializer.int(at: errorTypeColumn.columnIndex))
            guard let errorType = TSErrorMessageType(rawValue: errorTypeRaw) else {
               throw SDSError.invalidValue
            }
            let read = try deserializer.bool(at: readColumn.columnIndex)
            let recipientId = try deserializer.optionalString(at: recipientIdColumn.columnIndex)

            return TSInvalidIdentityKeyErrorMessage(uniqueId: uniqueId,
                                                    receivedAtTimestamp: receivedAtTimestamp,
                                                    sortId: sortId,
                                                    timestamp: timestamp,
                                                    uniqueThreadId: uniqueThreadId,
                                                    attachmentIds: attachmentIds,
                                                    body: body,
                                                    contactShare: contactShare,
                                                    expireStartedAt: expireStartedAt,
                                                    expiresAt: expiresAt,
                                                    expiresInSeconds: expiresInSeconds,
                                                    linkPreview: linkPreview,
                                                    messageSticker: messageSticker,
                                                    quotedMessage: quotedMessage,
                                                    schemaVersion: schemaVersion,
                                                    errorMessageSchemaVersion: errorMessageSchemaVersion,
                                                    errorType: errorType,
                                                    read: read,
                                                    recipientId: recipientId)

        case .invalidIdentityKeyReceivingErrorMessage:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: sortIdColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))
            let errorMessageSchemaVersion = UInt(try deserializer.int64(at: errorMessageSchemaVersionColumn.columnIndex))
            let errorTypeRaw = Int32(try deserializer.int(at: errorTypeColumn.columnIndex))
            guard let errorType = TSErrorMessageType(rawValue: errorTypeRaw) else {
               throw SDSError.invalidValue
            }
            let read = try deserializer.bool(at: readColumn.columnIndex)
            let recipientId = try deserializer.optionalString(at: recipientIdColumn.columnIndex)
            let authorId = try deserializer.string(at: authorIdColumn.columnIndex)
            let envelopeData = try deserializer.optionalBlob(at: envelopeDataColumn.columnIndex)

            return TSInvalidIdentityKeyReceivingErrorMessage(uniqueId: uniqueId,
                                                             receivedAtTimestamp: receivedAtTimestamp,
                                                             sortId: sortId,
                                                             timestamp: timestamp,
                                                             uniqueThreadId: uniqueThreadId,
                                                             attachmentIds: attachmentIds,
                                                             body: body,
                                                             contactShare: contactShare,
                                                             expireStartedAt: expireStartedAt,
                                                             expiresAt: expiresAt,
                                                             expiresInSeconds: expiresInSeconds,
                                                             linkPreview: linkPreview,
                                                             messageSticker: messageSticker,
                                                             quotedMessage: quotedMessage,
                                                             schemaVersion: schemaVersion,
                                                             errorMessageSchemaVersion: errorMessageSchemaVersion,
                                                             errorType: errorType,
                                                             read: read,
                                                             recipientId: recipientId,
                                                             authorId: authorId,
                                                             envelopeData: envelopeData)

        case .invalidIdentityKeySendingErrorMessage:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: sortIdColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))
            let errorMessageSchemaVersion = UInt(try deserializer.int64(at: errorMessageSchemaVersionColumn.columnIndex))
            let errorTypeRaw = Int32(try deserializer.int(at: errorTypeColumn.columnIndex))
            guard let errorType = TSErrorMessageType(rawValue: errorTypeRaw) else {
               throw SDSError.invalidValue
            }
            let read = try deserializer.bool(at: readColumn.columnIndex)
            let recipientId = try deserializer.optionalString(at: recipientIdColumn.columnIndex)
            let messageId = try deserializer.string(at: messageIdColumn.columnIndex)
            let preKeyBundleSerialized: Data = try deserializer.blob(at: preKeyBundleColumn.columnIndex)
            let preKeyBundle: PreKeyBundle = try SDSDeserializer.unarchive(preKeyBundleSerialized)

            return TSInvalidIdentityKeySendingErrorMessage(uniqueId: uniqueId,
                                                           receivedAtTimestamp: receivedAtTimestamp,
                                                           sortId: sortId,
                                                           timestamp: timestamp,
                                                           uniqueThreadId: uniqueThreadId,
                                                           attachmentIds: attachmentIds,
                                                           body: body,
                                                           contactShare: contactShare,
                                                           expireStartedAt: expireStartedAt,
                                                           expiresAt: expiresAt,
                                                           expiresInSeconds: expiresInSeconds,
                                                           linkPreview: linkPreview,
                                                           messageSticker: messageSticker,
                                                           quotedMessage: quotedMessage,
                                                           schemaVersion: schemaVersion,
                                                           errorMessageSchemaVersion: errorMessageSchemaVersion,
                                                           errorType: errorType,
                                                           read: read,
                                                           recipientId: recipientId,
                                                           messageId: messageId,
                                                           preKeyBundle: preKeyBundle)

        case .infoMessage:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: sortIdColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))
            let customMessage = try deserializer.optionalString(at: customMessageColumn.columnIndex)
            let infoMessageSchemaVersion = UInt(try deserializer.int64(at: infoMessageSchemaVersionColumn.columnIndex))
            let messageTypeRaw = Int(try deserializer.int(at: messageTypeColumn.columnIndex))
            guard let messageType = TSInfoMessageType(rawValue: messageTypeRaw) else {
               throw SDSError.invalidValue
            }
            let read = try deserializer.bool(at: readColumn.columnIndex)
            let unregisteredRecipientId = try deserializer.optionalString(at: unregisteredRecipientIdColumn.columnIndex)

            return TSInfoMessage(uniqueId: uniqueId,
                                 receivedAtTimestamp: receivedAtTimestamp,
                                 sortId: sortId,
                                 timestamp: timestamp,
                                 uniqueThreadId: uniqueThreadId,
                                 attachmentIds: attachmentIds,
                                 body: body,
                                 contactShare: contactShare,
                                 expireStartedAt: expireStartedAt,
                                 expiresAt: expiresAt,
                                 expiresInSeconds: expiresInSeconds,
                                 linkPreview: linkPreview,
                                 messageSticker: messageSticker,
                                 quotedMessage: quotedMessage,
                                 schemaVersion: schemaVersion,
                                 customMessage: customMessage,
                                 infoMessageSchemaVersion: infoMessageSchemaVersion,
                                 messageType: messageType,
                                 read: read,
                                 unregisteredRecipientId: unregisteredRecipientId)

        case .addToProfileWhitelistOfferMessage:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: sortIdColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))
            let customMessage = try deserializer.optionalString(at: customMessageColumn.columnIndex)
            let infoMessageSchemaVersion = UInt(try deserializer.int64(at: infoMessageSchemaVersionColumn.columnIndex))
            let messageTypeRaw = Int(try deserializer.int(at: messageTypeColumn.columnIndex))
            guard let messageType = TSInfoMessageType(rawValue: messageTypeRaw) else {
               throw SDSError.invalidValue
            }
            let read = try deserializer.bool(at: readColumn.columnIndex)
            let unregisteredRecipientId = try deserializer.optionalString(at: unregisteredRecipientIdColumn.columnIndex)
            let contactId = try deserializer.string(at: contactIdColumn.columnIndex)

            return OWSAddToProfileWhitelistOfferMessage(uniqueId: uniqueId,
                                                        receivedAtTimestamp: receivedAtTimestamp,
                                                        sortId: sortId,
                                                        timestamp: timestamp,
                                                        uniqueThreadId: uniqueThreadId,
                                                        attachmentIds: attachmentIds,
                                                        body: body,
                                                        contactShare: contactShare,
                                                        expireStartedAt: expireStartedAt,
                                                        expiresAt: expiresAt,
                                                        expiresInSeconds: expiresInSeconds,
                                                        linkPreview: linkPreview,
                                                        messageSticker: messageSticker,
                                                        quotedMessage: quotedMessage,
                                                        schemaVersion: schemaVersion,
                                                        customMessage: customMessage,
                                                        infoMessageSchemaVersion: infoMessageSchemaVersion,
                                                        messageType: messageType,
                                                        read: read,
                                                        unregisteredRecipientId: unregisteredRecipientId,
                                                        contactId: contactId)

        case .verificationStateChangeMessage:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: sortIdColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))
            let customMessage = try deserializer.optionalString(at: customMessageColumn.columnIndex)
            let infoMessageSchemaVersion = UInt(try deserializer.int64(at: infoMessageSchemaVersionColumn.columnIndex))
            let messageTypeRaw = Int(try deserializer.int(at: messageTypeColumn.columnIndex))
            guard let messageType = TSInfoMessageType(rawValue: messageTypeRaw) else {
               throw SDSError.invalidValue
            }
            let read = try deserializer.bool(at: readColumn.columnIndex)
            let unregisteredRecipientId = try deserializer.optionalString(at: unregisteredRecipientIdColumn.columnIndex)
            let isLocalChange = try deserializer.bool(at: isLocalChangeColumn.columnIndex)
            let recipientId = try deserializer.string(at: recipientIdColumn.columnIndex)
            let verificationStateRaw = UInt(try deserializer.int(at: verificationStateColumn.columnIndex))
            guard let verificationState = OWSVerificationState(rawValue: verificationStateRaw) else {
               throw SDSError.invalidValue
            }

            return OWSVerificationStateChangeMessage(uniqueId: uniqueId,
                                                     receivedAtTimestamp: receivedAtTimestamp,
                                                     sortId: sortId,
                                                     timestamp: timestamp,
                                                     uniqueThreadId: uniqueThreadId,
                                                     attachmentIds: attachmentIds,
                                                     body: body,
                                                     contactShare: contactShare,
                                                     expireStartedAt: expireStartedAt,
                                                     expiresAt: expiresAt,
                                                     expiresInSeconds: expiresInSeconds,
                                                     linkPreview: linkPreview,
                                                     messageSticker: messageSticker,
                                                     quotedMessage: quotedMessage,
                                                     schemaVersion: schemaVersion,
                                                     customMessage: customMessage,
                                                     infoMessageSchemaVersion: infoMessageSchemaVersion,
                                                     messageType: messageType,
                                                     read: read,
                                                     unregisteredRecipientId: unregisteredRecipientId,
                                                     isLocalChange: isLocalChange,
                                                     recipientId: recipientId,
                                                     verificationState: verificationState)

        case .addToContactsOfferMessage:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: sortIdColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))
            let customMessage = try deserializer.optionalString(at: customMessageColumn.columnIndex)
            let infoMessageSchemaVersion = UInt(try deserializer.int64(at: infoMessageSchemaVersionColumn.columnIndex))
            let messageTypeRaw = Int(try deserializer.int(at: messageTypeColumn.columnIndex))
            guard let messageType = TSInfoMessageType(rawValue: messageTypeRaw) else {
               throw SDSError.invalidValue
            }
            let read = try deserializer.bool(at: readColumn.columnIndex)
            let unregisteredRecipientId = try deserializer.optionalString(at: unregisteredRecipientIdColumn.columnIndex)
            let contactId = try deserializer.string(at: contactIdColumn.columnIndex)

            return OWSAddToContactsOfferMessage(uniqueId: uniqueId,
                                                receivedAtTimestamp: receivedAtTimestamp,
                                                sortId: sortId,
                                                timestamp: timestamp,
                                                uniqueThreadId: uniqueThreadId,
                                                attachmentIds: attachmentIds,
                                                body: body,
                                                contactShare: contactShare,
                                                expireStartedAt: expireStartedAt,
                                                expiresAt: expiresAt,
                                                expiresInSeconds: expiresInSeconds,
                                                linkPreview: linkPreview,
                                                messageSticker: messageSticker,
                                                quotedMessage: quotedMessage,
                                                schemaVersion: schemaVersion,
                                                customMessage: customMessage,
                                                infoMessageSchemaVersion: infoMessageSchemaVersion,
                                                messageType: messageType,
                                                read: read,
                                                unregisteredRecipientId: unregisteredRecipientId,
                                                contactId: contactId)

        case .disappearingConfigurationUpdateInfoMessage:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: sortIdColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))
            let customMessage = try deserializer.optionalString(at: customMessageColumn.columnIndex)
            let infoMessageSchemaVersion = UInt(try deserializer.int64(at: infoMessageSchemaVersionColumn.columnIndex))
            let messageTypeRaw = Int(try deserializer.int(at: messageTypeColumn.columnIndex))
            guard let messageType = TSInfoMessageType(rawValue: messageTypeRaw) else {
               throw SDSError.invalidValue
            }
            let read = try deserializer.bool(at: readColumn.columnIndex)
            let unregisteredRecipientId = try deserializer.optionalString(at: unregisteredRecipientIdColumn.columnIndex)
            let configurationDurationSeconds = UInt32(try deserializer.int64(at: configurationDurationSecondsColumn.columnIndex))
            let configurationIsEnabled = try deserializer.bool(at: configurationIsEnabledColumn.columnIndex)
            let createdByRemoteName = try deserializer.optionalString(at: createdByRemoteNameColumn.columnIndex)
            let createdInExistingGroup = try deserializer.bool(at: createdInExistingGroupColumn.columnIndex)

            return OWSDisappearingConfigurationUpdateInfoMessage(uniqueId: uniqueId,
                                                                 receivedAtTimestamp: receivedAtTimestamp,
                                                                 sortId: sortId,
                                                                 timestamp: timestamp,
                                                                 uniqueThreadId: uniqueThreadId,
                                                                 attachmentIds: attachmentIds,
                                                                 body: body,
                                                                 contactShare: contactShare,
                                                                 expireStartedAt: expireStartedAt,
                                                                 expiresAt: expiresAt,
                                                                 expiresInSeconds: expiresInSeconds,
                                                                 linkPreview: linkPreview,
                                                                 messageSticker: messageSticker,
                                                                 quotedMessage: quotedMessage,
                                                                 schemaVersion: schemaVersion,
                                                                 customMessage: customMessage,
                                                                 infoMessageSchemaVersion: infoMessageSchemaVersion,
                                                                 messageType: messageType,
                                                                 read: read,
                                                                 unregisteredRecipientId: unregisteredRecipientId,
                                                                 configurationDurationSeconds: configurationDurationSeconds,
                                                                 configurationIsEnabled: configurationIsEnabled,
                                                                 createdByRemoteName: createdByRemoteName,
                                                                 createdInExistingGroup: createdInExistingGroup)

        case .incomingMessage:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: sortIdColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))
            let authorId = try deserializer.string(at: authorIdColumn.columnIndex)
            let read = try deserializer.bool(at: readColumn.columnIndex)
            let serverTimestamp = try deserializer.optionalUInt64AsNSNumber(at: serverTimestampColumn.columnIndex)
            let sourceDeviceId = UInt32(try deserializer.int64(at: sourceDeviceIdColumn.columnIndex))
            let wasReceivedByUD = try deserializer.bool(at: wasReceivedByUDColumn.columnIndex)

            return TSIncomingMessage(uniqueId: uniqueId,
                                     receivedAtTimestamp: receivedAtTimestamp,
                                     sortId: sortId,
                                     timestamp: timestamp,
                                     uniqueThreadId: uniqueThreadId,
                                     attachmentIds: attachmentIds,
                                     body: body,
                                     contactShare: contactShare,
                                     expireStartedAt: expireStartedAt,
                                     expiresAt: expiresAt,
                                     expiresInSeconds: expiresInSeconds,
                                     linkPreview: linkPreview,
                                     messageSticker: messageSticker,
                                     quotedMessage: quotedMessage,
                                     schemaVersion: schemaVersion,
                                     authorId: authorId,
                                     read: read,
                                     serverTimestamp: serverTimestamp,
                                     sourceDeviceId: sourceDeviceId,
                                     wasReceivedByUD: wasReceivedByUD)

        case .outgoingMessage:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: sortIdColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let attachmentIdsSerialized: Data = try deserializer.blob(at: attachmentIdsColumn.columnIndex)
            let attachmentIds: [String] = try SDSDeserializer.unarchive(attachmentIdsSerialized)
            let body = try deserializer.optionalString(at: bodyColumn.columnIndex)
            let contactShareSerialized: Data? = try deserializer.optionalBlob(at: contactShareColumn.columnIndex)
            let contactShare: OWSContact? = try SDSDeserializer.optionalUnarchive(contactShareSerialized)
            let expireStartedAt = try deserializer.uint64(at: expireStartedAtColumn.columnIndex)
            let expiresAt = try deserializer.uint64(at: expiresAtColumn.columnIndex)
            let expiresInSeconds = UInt32(try deserializer.int64(at: expiresInSecondsColumn.columnIndex))
            let linkPreviewSerialized: Data? = try deserializer.optionalBlob(at: linkPreviewColumn.columnIndex)
            let linkPreview: OWSLinkPreview? = try SDSDeserializer.optionalUnarchive(linkPreviewSerialized)
            let messageStickerSerialized: Data? = try deserializer.optionalBlob(at: messageStickerColumn.columnIndex)
            let messageSticker: MessageSticker? = try SDSDeserializer.optionalUnarchive(messageStickerSerialized)
            let quotedMessageSerialized: Data? = try deserializer.optionalBlob(at: quotedMessageColumn.columnIndex)
            let quotedMessage: TSQuotedMessage? = try SDSDeserializer.optionalUnarchive(quotedMessageSerialized)
            let schemaVersion = UInt(try deserializer.int64(at: schemaVersionColumn.columnIndex))
            let attachmentFilenameMapSerialized: Data = try deserializer.blob(at: attachmentFilenameMapColumn.columnIndex)
            let attachmentFilenameMap: [String: String] = try SDSDeserializer.unarchive(attachmentFilenameMapSerialized)
            let customMessage = try deserializer.optionalString(at: customMessageColumn.columnIndex)
            let groupMetaMessageRaw = Int(try deserializer.int(at: groupMetaMessageColumn.columnIndex))
            guard let groupMetaMessage = TSGroupMetaMessage(rawValue: groupMetaMessageRaw) else {
               throw SDSError.invalidValue
            }
            let hasLegacyMessageState = try deserializer.bool(at: hasLegacyMessageStateColumn.columnIndex)
            let hasSyncedTranscript = try deserializer.bool(at: hasSyncedTranscriptColumn.columnIndex)
            let isFromLinkedDevice = try deserializer.bool(at: isFromLinkedDeviceColumn.columnIndex)
            let isVoiceMessage = try deserializer.bool(at: isVoiceMessageColumn.columnIndex)
            let legacyMessageStateRaw = Int(try deserializer.int(at: legacyMessageStateColumn.columnIndex))
            guard let legacyMessageState = TSOutgoingMessageState(rawValue: legacyMessageStateRaw) else {
               throw SDSError.invalidValue
            }
            let legacyWasDelivered = try deserializer.bool(at: legacyWasDeliveredColumn.columnIndex)
            let mostRecentFailureText = try deserializer.optionalString(at: mostRecentFailureTextColumn.columnIndex)
            let recipientStateMapSerialized: Data? = try deserializer.optionalBlob(at: recipientStateMapColumn.columnIndex)
            let recipientStateMap: [String: TSOutgoingMessageRecipientState]? = try SDSDeserializer.optionalUnarchive(recipientStateMapSerialized)

            return TSOutgoingMessage(uniqueId: uniqueId,
                                     receivedAtTimestamp: receivedAtTimestamp,
                                     sortId: sortId,
                                     timestamp: timestamp,
                                     uniqueThreadId: uniqueThreadId,
                                     attachmentIds: attachmentIds,
                                     body: body,
                                     contactShare: contactShare,
                                     expireStartedAt: expireStartedAt,
                                     expiresAt: expiresAt,
                                     expiresInSeconds: expiresInSeconds,
                                     linkPreview: linkPreview,
                                     messageSticker: messageSticker,
                                     quotedMessage: quotedMessage,
                                     schemaVersion: schemaVersion,
                                     attachmentFilenameMap: attachmentFilenameMap,
                                     customMessage: customMessage,
                                     groupMetaMessage: groupMetaMessage,
                                     hasLegacyMessageState: hasLegacyMessageState,
                                     hasSyncedTranscript: hasSyncedTranscript,
                                     isFromLinkedDevice: isFromLinkedDevice,
                                     isVoiceMessage: isVoiceMessage,
                                     legacyMessageState: legacyMessageState,
                                     legacyWasDelivered: legacyWasDelivered,
                                     mostRecentFailureText: mostRecentFailureText,
                                     recipientStateMap: recipientStateMap)

        case .call:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: sortIdColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let callSchemaVersion = UInt(try deserializer.int64(at: callSchemaVersionColumn.columnIndex))
            let callTypeRaw = UInt(try deserializer.int(at: callTypeColumn.columnIndex))
            guard let callType = RPRecentCallType(rawValue: callTypeRaw) else {
               throw SDSError.invalidValue
            }
            let read = try deserializer.bool(at: readColumn.columnIndex)

            return TSCall(uniqueId: uniqueId,
                          receivedAtTimestamp: receivedAtTimestamp,
                          sortId: sortId,
                          timestamp: timestamp,
                          uniqueThreadId: uniqueThreadId,
                          callSchemaVersion: callSchemaVersion,
                          callType: callType,
                          read: read)

        case .contactOffersInteraction:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: sortIdColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)
            let beforeInteractionId = try deserializer.string(at: beforeInteractionIdColumn.columnIndex)
            let hasAddToContactsOffer = try deserializer.bool(at: hasAddToContactsOfferColumn.columnIndex)
            let hasAddToProfileWhitelistOffer = try deserializer.bool(at: hasAddToProfileWhitelistOfferColumn.columnIndex)
            let hasBlockOffer = try deserializer.bool(at: hasBlockOfferColumn.columnIndex)
            let recipientId = try deserializer.string(at: recipientIdColumn.columnIndex)

            return OWSContactOffersInteraction(uniqueId: uniqueId,
                                               receivedAtTimestamp: receivedAtTimestamp,
                                               sortId: sortId,
                                               timestamp: timestamp,
                                               uniqueThreadId: uniqueThreadId,
                                               beforeInteractionId: beforeInteractionId,
                                               hasAddToContactsOffer: hasAddToContactsOffer,
                                               hasAddToProfileWhitelistOffer: hasAddToProfileWhitelistOffer,
                                               hasBlockOffer: hasBlockOffer,
                                               recipientId: recipientId)

        case .interaction:

            let uniqueId = try deserializer.string(at: uniqueIdColumn.columnIndex)
            let receivedAtTimestamp = try deserializer.uint64(at: receivedAtTimestampColumn.columnIndex)
            let sortId = try deserializer.uint64(at: sortIdColumn.columnIndex)
            let timestamp = try deserializer.uint64(at: timestampColumn.columnIndex)
            let uniqueThreadId = try deserializer.string(at: uniqueThreadIdColumn.columnIndex)

            return TSInteraction(uniqueId: uniqueId,
                                 receivedAtTimestamp: receivedAtTimestamp,
                                 sortId: sortId,
                                 timestamp: timestamp,
                                 uniqueThreadId: uniqueThreadId)

        default:
            owsFail("Invalid record type \(recordType)")
        }
    }
}

// MARK: - Save/Remove/Update

@objc
extension TSInteraction {
    @objc
    public func anySave(transaction: SDSAnyWriteTransaction) {
        switch transaction.writeTransaction {
        case .yapWrite(let ydbTransaction):
            save(with: ydbTransaction)
        case .grdbWrite(let grdbTransaction):
            SDSSerialization.save(entity: self, transaction: grdbTransaction)
        }
    }

    // This method is used by "updateWith..." methods.
    //
    // This model may be updated from many threads. We don't want to save
    // our local copy (this instance) since it may be out of date.  We also
    // want to avoid re-saving a model that has been deleted.  Therefore, we
    // use "updateWith..." methods to:
    //
    // a) Update a property of this instance.
    // b) If a copy of this model exists in the database, load an up-to-date copy,
    //    and update and save that copy.
    // b) If a copy of this model _DOES NOT_ exist in the database, do _NOT_ save
    //    this local instance.
    //
    // After "updateWith...":
    //
    // a) Any copy of this model in the database will have been updated.
    // b) The local property on this instance will always have been updated.
    // c) Other properties on this instance may be out of date.
    //
    // All mutable properties of this class have been made read-only to
    // prevent accidentally modifying them directly.
    //
    // This isn't a perfect arrangement, but in practice this will prevent
    // data loss and will resolve all known issues.
    @objc
    public func anyUpdateWith(transaction: SDSAnyWriteTransaction, block: (TSInteraction) -> Void) {
        guard let uniqueId = uniqueId else {
            owsFailDebug("Missing uniqueId.")
            return
        }

        guard let dbCopy = type(of: self).anyFetch(uniqueId: uniqueId,
                                                   transaction: transaction) else {
            return
        }

        block(self)
        block(dbCopy)

        dbCopy.anySave(transaction: transaction)
    }

    @objc
    public func anyRemove(transaction: SDSAnyWriteTransaction) {
        switch transaction.writeTransaction {
        case .yapWrite(let ydbTransaction):
            remove(with: ydbTransaction)
        case .grdbWrite(let grdbTransaction):
            SDSSerialization.delete(entity: self, transaction: grdbTransaction)
        }
    }
}

// MARK: - TSInteractionCursor

@objc
public class TSInteractionCursor: NSObject {
    private let cursor: SDSCursor<TSInteraction>

    init(cursor: SDSCursor<TSInteraction>) {
        self.cursor = cursor
    }

    // TODO: Revisit error handling in this class.
    public func next() throws -> TSInteraction? {
        return try cursor.next()
    }

    public func all() throws -> [TSInteraction] {
        return try cursor.all()
    }
}

// MARK: - Obj-C Fetch

// TODO: We may eventually want to define some combination of:
//
// * fetchCursor, fetchOne, fetchAll, etc. (ala GRDB)
// * Optional "where clause" parameters for filtering.
// * Async flavors with completions.
//
// TODO: I've defined flavors that take a read transaction.
//       Or we might take a "connection" if we end up having that class.
@objc
extension TSInteraction {
    public class func grdbFetchCursor(transaction: GRDBReadTransaction) -> TSInteractionCursor {
        return TSInteractionCursor(cursor: SDSSerialization.fetchCursor(tableMetadata: TSInteractionSerializer.table,
                                                                   transaction: transaction,
                                                                   deserialize: TSInteractionSerializer.sdsDeserialize))
    }

    // Fetches a single model by "unique id".
    @objc
    public class func anyFetch(uniqueId: String,
                               transaction: SDSAnyReadTransaction) -> TSInteraction? {
        assert(uniqueId.count > 0)

        switch transaction.readTransaction {
        case .yapRead(let ydbTransaction):
            return TSInteraction.fetch(uniqueId: uniqueId, transaction: ydbTransaction)
        case .grdbRead(let grdbTransaction):
            let tableMetadata = TSInteractionSerializer.table
            let columnNames: [String] = tableMetadata.selectColumnNames
            let columnsSQL: String = columnNames.map { $0.quotedDatabaseIdentifier }.joined(separator: ", ")
            let tableName: String = tableMetadata.tableName
            let uniqueIdColumnName: String = TSInteractionSerializer.uniqueIdColumn.columnName
            let sql: String = "SELECT \(columnsSQL) FROM \(tableName.quotedDatabaseIdentifier) WHERE \(uniqueIdColumnName.quotedDatabaseIdentifier) == ?"

            let cursor = TSInteraction.grdbFetchCursor(sql: sql,
                                                  arguments: [uniqueId],
                                                  transaction: grdbTransaction)
            do {
                return try cursor.next()
            } catch {
                owsFailDebug("error: \(error)")
                return nil
            }
        }
    }
}

// MARK: - Swift Fetch

extension TSInteraction {
    public class func grdbFetchCursor(sql: String,
                                      arguments: [DatabaseValueConvertible]?,
                                      transaction: GRDBReadTransaction) -> TSInteractionCursor {
        var statementArguments: StatementArguments?
        if let arguments = arguments {
            guard let statementArgs = StatementArguments(arguments) else {
                owsFail("Could not convert arguments.")
            }
            statementArguments = statementArgs
        }
        return TSInteractionCursor(cursor: SDSSerialization.fetchCursor(sql: sql,
                                                             arguments: statementArguments,
                                                             transaction: transaction,
                                                                   deserialize: TSInteractionSerializer.sdsDeserialize))
    }
}

// MARK: - SDSSerializer

// The SDSSerializer protocol specifies how to insert and update the
// row that corresponds to this model.
class TSInteractionSerializer: SDSSerializer {

    private let model: TSInteraction
    public required init(model: TSInteraction) {
        self.model = model
    }

    public func serializableColumnTableMetadata() -> SDSTableMetadata {
        return TSInteractionSerializer.table
    }

    public func insertColumnNames() -> [String] {
        // When we insert a new row, we include the following columns:
        //
        // * "record type"
        // * "unique id"
        // * ...all columns that we set when updating.
        return [
            TSInteractionSerializer.recordTypeColumn.columnName,
            uniqueIdColumnName()
            ] + updateColumnNames()

    }

    public func insertColumnValues() -> [DatabaseValueConvertible] {
        let result: [DatabaseValueConvertible] = [
            SDSRecordType.interaction.rawValue
            ] + [uniqueIdColumnValue()] + updateColumnValues()
        if OWSIsDebugBuild() {
            if result.count != insertColumnNames().count {
                owsFailDebug("Update mismatch: \(result.count) != \(insertColumnNames().count)")
            }
        }
        return result
    }

    public func updateColumnNames() -> [String] {
        return [
            TSInteractionSerializer.receivedAtTimestampColumn,
            TSInteractionSerializer.sortIdColumn,
            TSInteractionSerializer.timestampColumn,
            TSInteractionSerializer.uniqueThreadIdColumn
            ].map { $0.columnName }
    }

    public func updateColumnValues() -> [DatabaseValueConvertible] {
        let result: [DatabaseValueConvertible] = [
            self.model.receivedAtTimestamp,
            self.model.sortId,
            self.model.timestamp,
            self.model.uniqueThreadId

        ]
        if OWSIsDebugBuild() {
            if result.count != updateColumnNames().count {
                owsFailDebug("Update mismatch: \(result.count) != \(updateColumnNames().count)")
            }
        }
        return result
    }

    public func uniqueIdColumnName() -> String {
        return TSInteractionSerializer.uniqueIdColumn.columnName
    }

    // TODO: uniqueId is currently an optional on our models.
    //       We should probably make the return type here String?
    public func uniqueIdColumnValue() -> DatabaseValueConvertible {
        // FIXME remove force unwrap
        return model.uniqueId!
    }
}
